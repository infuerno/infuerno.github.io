---
layout: post
title: "Advanced "
---
# Module 1. Fallacies of Distributed Computing
## Systems vs. Applications

Application
: Single executable running on a single machine. Not aware of connectivity e.g. network drive availability

System 
: Multiple executable running on a single machine (or different machines = distributed system). Must deal with connectivity, various executables communicating with each other. Therefore single executables within a system are still NOT applications since they need also to deal with connectivity. Trying to abstract away the network doesn't tend to work out that well.

Peter Deutsch ('94) and James Gosling ('97) popularlised 8 fallacies. See: http://www.rgoarchitects.com/Files/fallacies.pdf. 

```
var svc = new MyService();
var response = svc.Process(data);
```

## Fallacy 1. The network is reliable

Dealing with outages when developing a solution over HTTP can involve coping with failure by using Retry & Ack / Store & Forward / Transactions. DON'T. Don't roll your own - too many edge cases. 

Use reliable messaging infrastructure instead.
* Microsoft: MSMQ, SQL Server Service Broker
* Azure: Azure Service Bus, Azure Storage Queues
* Java: IBM WebSphere MQ, Oracle, Tipco, Apache 

## Fallacy 2. Latency isn't a problem (0)

Latency is the time to cross the network in **one direction** (not a round trip because other things start getting involved e.g. data serialisation).

As you communicate across network boundaries, latency times increase in **orders of magnitude**.

Don't do remote objects. Don't do things that walk, talk, quack like remote objects.

Accessing properties on objects where a remote call was required PER PROPERTY was recognised as bad. Now use DTOs to get the data all at once. However what about ORM lazy-loading behaviour.

If you need to cross the network - grab all the data you need up front.

## Fallacy 3. Bandwidth isn't a problem (infinite)

Serves as a balancy effect against Fallacy 2. Not so easy to measure.
Growing **much more slowy** than volumes of data. Common standard is Gigabit ethernet. 10Gb Ethernet started getting rolled out approx 5 years ago.

>1Gb/s = approx 128MB/s raw ethernet = approx 60MB/s TCP = approx 30MB/s unserialized data

>Never underestimate the bandwidth of a trailer load of hard drives driving down the motorway

In order to balance the constraints of latency and bandwidth, may have to deconstruct data model into multiple domain models to resolve.

Could set up two seperate networks, regular and high priority. Split API into seperate APIs and service the business critical APIs over the higher priority network. Introduce complexity by doing this, but potentially can just split the API and keep it on the same network - now have options to split at a later date. 

## Fallacy 4. Network is secure

>The only secure machine is one that is disconnected from the network, preferably off and buried in concrete.

Need to balance the risk against the cost. Not a question of **if** you will get hacked, but **when**.

## Fallacy 5. The topology won't change

Programming issues which can run into issues when the machines are more volatile.

WCF callback contracts - full duplex communication between the client and the server. The server holds on to the address of the client in order to push back data. Great for events or notifications. Problem happens when the topology changes and the client is no longer there. If this is synchronous and blocking, may well tie up a thread (HTTP timeout is by default 30 seconds). Attack vector. Clients which are no longer there may end up affecting the runtime performance of the server.

* Don't hardcode IP addresses
* Consider using multicast
* Discovery mechanisms are great, but hard to get right and opaque to understand when they don't work

>Performance test early.

Best way out if you forget: buy one really big box and deploy EVERYTHING on it! You've written a monolithic system - you need a monolithic deployment!

## Fallacy 6. The admin will know what to do

The more config, the more moving parts, the more likely they'll get out of sync and something is not going to work. Invest in good config management. Create stable runpoints, backups. LOTS OF DOCUMENTATION ON CONFIG MANAGEMENT. Don't reinvent the wheel.

* Make smaller changes to more loosely coupled pieces of code
* Consider multiple versions running in parallel
* Don't do continuous deployment unless you can deploy without downtime
* Allow sys admins to take down parts of the system at one time - queues help with this (not the only way)
* Logging - some can be good - a lot can be harmful - don't make bigger haystacks

## Fallacy 7. Transport cost isn't a problem

Not just transport, but also serialisation and deserialisation. Often don't profile the serialisation and the CPU time that takes, but this can add up to quite a lot, particularly with cloud.

Watch out for transport costs. They tend to have an expotential factor as they operate over larger and larger links.

## Fallacy 8. The network is homogeneous

Used to be more standards 10 years ago when simply .NET and Java. Now anything goes. Will take another 5 to 10 years until someone says, stop. Need standards. Then at least another 20 until we are back where we were in 2005.

> REST. Colloquially known as something I hacked together over HTTP that might or might not work with something you hacked together over HTTP.

> NoSQL. None of your reporting systems will work on top of this data model

Semantic interoperability will always be hard, budget for it. Example of ER system with NULL DOB needs to pass patient object to medication system with mandatory DOB. Ended up having to code both systems to deal with age ranges. When this happens will have to do some big rewrites.

>Hofstadter's Law: It always takes longer than you expect, even when you take into account Hofstadter's Law.

## Fallacy 9. The system is atomic

The next 4 fallacies are about Enterprise Systems.

This fallacy is concerned with technical forces which influence a system deteriorating and turning into a big ball of mud.

* Integration via the database e.g. passing an ID rather than the whole object - explicit coupling
* Putting JSON / XML in the database just makes the problem worse

