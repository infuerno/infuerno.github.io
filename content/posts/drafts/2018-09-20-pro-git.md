---
layout: post
title: "Pro Git"
---
## 1 Getting Started (page 1)
### About Version Control

* Local VCS e.g. copy files, RCS (patch sets = differences between files) - no good for collaboration; single point of failure
* Centralized VCS e.g. CVS, Subversion, Perforce - single server with all files, client checkout files - needs central server to be available, also single point of failure
* Distributed VCS e.g. Git, Mercurial - complete copy of repo on each client, collaberate with different people in different ways

### A Short History of Git

Developed in 2005 by the Linux kernel team after the propriatary DVCS tool they were using (BitKeeper) revoked the free-of-charge status. As per the original design goal, it is fast, efficient with large projects and has a strong branching system

### Git Basics

Git stores and thinks about information in a very different way to other version control systems, so it is important to understand the main concepts. 

* Snapshots, Not Differences. Most systems store data as a list of file based changes i.e. a set of files and the changes made to those files over time aka delta-based version control. Git instead thinks of its data as a stream of snapshots. When you commit, Git takes a snapshot of your files. If the file hasn't changed a link to the previous file is stored instead. This fundamental difference means nearly every aspect of version control has been reconsidered. More in Git Branching.
* Nearly Every Operation Is Local. Much faster. Very little you can't do locally
* Git Has Integrity. Git checksums everything using SHA-1 hash which means nothing can get corrupted or changed without Git knowing about it
* Git Generally Only Adds Data. After commiting a snapshot into Git it is very difficult to lose.
* The Three States. V IMPORTANT. There are three main states a file can be in: committed, modified and staged. Can it be both staged and modified when a file has been staged, but further changes have been made? These correspond to the 3 sections of a Git project: the `.git` directory, the working tree and the staging area. The `.git` directory contains the metadata and object data for the repo. The working tree is a single checkout out of one version, pulled from the `.git` directory. The staging area or index is a file (usually within `.git`) containing details of the next commit.

### First-Time Git Setup

* Using the `git config` tool 
* Stores configs in one of 3 places:
    - system wide in `/etc/gitconfig` - using the `--system` flag
    - per user in `~/.gitconfig` or `~/.config/git/config` using the `--global` flag
    - per repo in `.git/config` default OR using the `--local` flag to be explicit
* Windows locations are completely different
* Always set `user.name` and `user.email` after installation (can always override on project by project basis if nec)
* `core.editor` to use a different editor to the system default
* `core.autocrlf input|true|false` to control how line endings are treated 
* `git config --list` to show all settings (contextual to the git repo if appropriate). Settings may appear more than once, last one is used
* `git config user.name` to query the value of a particular setting - use with `--show-origin` to show where configured
* `git config --global credential.helper cache` to cache your password in memory (to save having to type it every time a remote command is issued)

### Getting Help

* `git help <verb>` OR `man git-<verb>` to bring up the various man pages e.g. `man git`, `man git-branch`

>git - the stupid content tracker
>We divide Git into high level ("porcelain") commands and low level ("plumbing") commands.

## 2 Git Basics (page 25)

### Adding Files, Staging Modified Files

`git add` is a multipurpose command

* begin tracking new files
* stage files
* mark merge-conflicted files as resolved

If a file is modified after running `git add`, it needs to be run again to stage the latest version of the file.

### Short Status

`git status --short` (`git status -s`) short status showing two columns of statuses, first one for staging area, second one for working tree

### Ignoring Files

Rules for the patterns in the `.gitignore`:

* Blank lines or lines starting with # are ignored
* Standard glob patterns work, and will be applied recursively throughout the entire working tree
* Starting patterns with a forward slash (/) to avoid recursivity
* Ending patterns with a forward slash (/) to specify a directory
* Negate patterns by starting it with an exclamation point (!)

Comprehensive list of .gitignore file examples for different projects and languages at https://github.com/github/gitignore. Multiple `.gitignore` files are also possible. `.gitignore` files in subdirectories only apply to that directory

### Viewing Changes

* `git diff --staged` ( or `git diff --cached`) to diff staged files. If a file has modifications since being staged, the two different edits can be seen using `git diff` and `git diff -staged`.
* `git difftool` to view diffs in external software e.g. emerge, vimdiff etc
* `git difftool --tool-help` for locally available tools

### Committing Changes

* `git commit` by itself will launch the editor, with the files to be commited in a comment. Any comment lines are stripped out of the commit message.
* `git commit -v` will additionally show the diff (again will be stripped out of the actual commit message)

### Skipping the Staging Area

Skip `git add` by using `git commit -a` - will commit every file with changes already being tracked. USE WITH CAUTION.

### Removing Files

* `git rm` to mark a file for removal. Will be deleted from the working tree on commit. If the file already has staged changes, the `-f` flag must be used to remove it (since the changes staged will be lost since not part of any commit snapshot).
* `git rm --cached` to unstage a file
* Files, directories and file-glob patterns can all be used

### Viewing the Commit History

* `git log` shows commit info in descending order
* `git log -p` shows each patch
* `git log --stat` with stats
* `git log -pretty=online` or various other
* `git log -pretty=format:"%h %ae %s` with various options available for format
* `git log --graph` to show an ASCII branch and merge history e.g. `git log --pretty=format:"%h %s" --graph`
* `git log --since=2.weeks`
* `git log --author [email]`
* `git log --grep bug`
* `git log --all-match -grep bug --author [email]` default behaviour is to match any of the matches, add `all-match` to match all
* Pickaxe: `git log -p -2 -S showInputMenu` to show commits (including diff) which contained "showInputMenu" somewhere in the diff
* `git log --no-merges` don't show merge commits (may be useful depending on workflow used)

### Undoing Things

* `git commit --amend` redo your last commit - if nothing else staged just the message, otherwise if additional files have been staged, these will be added
* Can also unstage files and undo pending changes - HOWEVER be aware that any changes not committed will be completely lost. Usually better to stash or branch.

### Working with Remotes

The url of a remote is assigned an alias. For example `origin` is used when initially using `git clone`. Add a remote manually using `git remote add <alias> <url>` Use `git fetch` to pull down all the information from the remote repo to your local machine. Branches from the remote repo are now accessible locally at `<alias>/<branchname>` e.g. `origin/master`. This can be be merged into an existing branch in the local repo OR a local copy checked out.

If a local branch is set to track a remote branch (automatically done when using `git clone`) then `git pull` can be used to do a `git fetch` followed by a `git merge`.

`git remote show origin` to show information about a remote repo, remote branches and any tracking in place with local branches

### Tagging

* `git tag` to list tags or `git tag -l "v1.8.5*"` for all tags matching a certain pattern
* Lightweight tag - pointer to a specific commit
* Annotated tags - recommended - stored as full objects: checksummed with tagger name, email, date and message and can be signed e.g. `git tag -a v1.4 -m "my version 1.4"` (as with commit, omitting the `-m` will launch the default editor). Use `git show` to see the tag data e.g. `git show v1.4`
* Tag a specific commit using the short hash e.g. `git tag -a v1.2 9fceb02`
* Tags are shared with remotes automatically, but need to be pushed

#### Checking out Tags

To see the contents of the files a tag is pointing to, the tag needs to be checked out e.g. `git checkout v1.4`. NOTE: this puts the repository in "detached HEAD" state. In this state, commits can be made, but won't be attached to any branch, so will be unreachable (except via the commit hash). If a branch is required use: `git checkout -b version2 v2.0.0`. 

### Git Aliases

Create aliases for git commands via config:

* `git config --global alias.co checkout` to then use `git co -b new-branch`
* `git config --global alias.unstage 'reset HEAD --'` to more easily unstage a file `git unstage file.txt`
* `git config --global alias.last 'log -1 HEAD'` to easily see the last commit

Use `!` for commands which aren't git subcommands:

* `git config --global alias.visual '!gitk'` to then use `gitk` instead of `git visual`

## 3 Git Branching (page 61)

Git branching is fast and git encourages workflows which branch and merge often. Understanding git branching requires understanding how git stores data. Git stores data as a series of snapshopts. 

### Branches in a Nutshell

A commit object contains:

* the author's name and email
* the commit message
* a pointer to the snapshot which was staged
* pointers to the previous commit (or commits when it is the result of the merge between multiple branches)

Stage: checksum each file, store that file version in the Git repository (blob)
Commit: checksum each subdirectory, store tree objects, create commit object

A branch is simply a (movable) pointer to a commit object. 

HEAD is a special pointer which points to the current branch. `git log --decorate` shows where the branch pointers are currently pointing (info also included in `git log --oneline`)

Checking out a different branch changes where the HEAD is pointing to AS WELL AS updating files in the working directory. IF this cannot be done cleanly (e.g. because there are unstaged changes) Git will not let you switch.

Useful log command to see branch info: `git log --oneline --decorate --graph --all`

### Basic Branching and Merging

Switching between branching is straightforwards if you have a clean working area. If the working directory or staging area has uncommitted changes, stashing and commit amending may be required (more later).

Merge hotfix branches back into master using `git checkout master && git merge hotfix`. If there is no divergent history Git will just fast-foward master (i.e. move the branch pointer forwards). Having merged back, delete brances no long required: `git branch -d hotfix`. NOTE master may also need to be merged into other branches now.

When there is divergent history, Git does a three-way merge using the snapshots of both tips and the snapshot of the common ancestor of the two branches. This involves creating a new snapshot and is called *merge commit*. This new snapshot has more than one parent. If Git can't merge this automatically the merge results in conflicts which need to be resolved. Edit each file and "stage" them to mark them resolved.

`git mergetool` to resolve conflicts in the visual merge tool configured.

### Branch Management

* `git branch -v` to see the list of branches as well as the last commit on each branch
* `git branch --merged` for all branches which have been merged into the current working branch (and therefore safe to delete)
* `git branch --no-merged` for any branches still to be merged (trying to delete such a branch will give a warning)
* Specify a branch name last for another branch

### Branching Workflows

#### Long-Running Branches

3 branches:

* `master` - stable code (has or will be released)
* `develop` or `next` - work from this branch or use to test stability
* `pu` or `proposed` - proposed update branch - for integrated work not yet ready to go into `next`
* `topic` - single short-lived branch for a particular feature

Work is merged into the branch above when it is more stable. This workflow is often helpful when dealing with large or complex projects.

#### Topic Branches

Short-lived branches for a singular feature or piece of work. In Git it’s common to create, work on, merge, and delete branches several times a day.

### Remote Branches

Remote references = references (pointers) in remote repositories inc branches and tags. Get a full list showing `git ls-remote [remote]` or `git remote show [remote]`.

A **remote-tracking branch** is a reference to the state of a remote branch. Git keeps this up to date with the remote branch whenever there is network connectivity. These references take the form of `<remote>/<branch>` e.g. `origin/master`. This remote-tracking branch therefore represents the branch on the server.

When cloning a repo from a server Git will copy the repo locally and both `origin/master` and `master` will point to the same commit. As changes are commited locally, the `master` branch pointer moves forward. When remote changes are `fetch`ed from the server, Git updates the repo to reflect a likely divergence of commits in the remote branch to the local branch (similar to the state of a local repo where different development happens on two different branches).

* `git fetch` updates any remote-tracking branches
* `git push origin <branch>` to push local `<branch>` to a remote branch on origin also called `<branch>`
* `git push origin <localbranch>:<remotebranch>` to give the remote branch a different name

Using `fetch` only updates the remote-tracking branches (or references / pointers). To use the code either merge with a local branch `git merge origin/<branch>` or create a local branch `git checkout -b <branch> origin/<branch>`.

#### Tracking Branches

A tracking branch is a local branch which tracks an upstream branch via a remote-tracking branch. The above command `git checkout -b <branch> origin/<branch>` can be shortened using `--track` to `git checkout --track origin/<branch>`. This can be further shortened to `git checkout <branch>` IF `<branch>` does not already exist locally AND there is only one remote with a branch of that name.

* `git branch -vv`
### Rebasing










## 4 Git on the Server (page 101)
## 5 Distributed Git (page 122)
## 6 GitHub (page 163)
## 7 Git Tools (page 215)
## 8 Customizing Git (page 334)
## 9 Git and Other Systems (page 365)
## 10 Git Internals (page 430)
## Appendix A: Git in Other Environments (page 470)
## Appendix B: Embedding Git in your Applications (page 483)
## Appendix C: Git Commands (page 495)