I"Û0<h2 id="refereces">Refereces</h2>

<ul>
  <li>Angular Getting Started:</li>
  <li>Angular First Look: Differences between Ng1 and Ng2 https://app.pluralsight.com/library/courses/angular-2-first-look/table-of-contents</li>
  <li>Angular Component Communication: https://app.pluralsight.com/library/courses/angular-component-communication/table-of-contents</li>
  <li>Blog post: https://blogs.msmvps.com/deborahk/angular-ngrx-getting-started-problem-solver/</li>
  <li>GitHub repo:</li>
</ul>

<h1 id="introduction">Introduction</h1>

<ul>
  <li>Manages state and interactions with that state for Angular apps using the Redux pattern</li>
  <li>State can include:
    <ul>
      <li>information about the view - whether to show or hide elements</li>
      <li>user information e.g. user‚Äôs name and roles</li>
      <li>entity data e.g. product information originally retrieved from and stored on a backend server</li>
      <li>user input selection</li>
    </ul>
  </li>
</ul>

<p><img src="https://www.dropbox.com/s/tkd3tk5ai9t1ty6/pluralsight-ngrx-redux-pattern.png?raw=1" alt="Redux pattern" /></p>

<ol>
  <li>User clicks on a tick box on the view to display product codes (if they browse away from this page, we forget their previous choice, so instead store this)</li>
  <li><strong>View</strong> uses event binding to notify the component of the <strong>User Event</strong></li>
  <li><strong>Component</strong> creates an <strong>action</strong> representing that <strong>event</strong>, including a payload - in this case a boolean representing the state of the tick box</li>
  <li>The <strong>Component</strong> <strong>dispatch</strong>es the Action to a dispatcher function called a <strong>reducer</strong></li>
  <li>The <strong>Reducer</strong> uses the <strong>action</strong> AND the <strong>current state</strong> to define <strong>new state</strong>. It updates the store with the <strong>new state</strong>.</li>
  <li>The <strong>Store</strong> is single, in memory, client side, state container containing application state while the application is running. The state is immutable.</li>
  <li>Compnents subscribe to the <strong>store</strong> using a <strong>selector</strong>. The <strong>selector</strong> knows how to locate and return information from the store.</li>
  <li>When new state is replaced in the store, the component is notified of the state and bound values in the view are updated.</li>
  <li>If a user browses away and back, the component resubscribes and gets the current state from the store. The view is then updated with the retained user‚Äôs selection.</li>
</ol>

<p>Can be used for more complex interactions e.g.</p>

<ul>
  <li>Multiple component communication</li>
  <li>Loading data from a backend server</li>
  <li>Create, update and delete operations</li>
</ul>

<h2 id="why-use-ngrx">Why use NgRx</h2>

<h3 id="state-everywhere">State everywhere</h3>

<p>Without NgRx, usually have many services each holding little bits of state. With NgRx, this can be replaced by a single store.</p>

<h3 id="getting-data-again-and-again">Getting data again and again</h3>

<p>Without NgRx, often have services which call backend APIs and components which call the service ngOnInit() to retrieve the data. If a user browses away and then back, this often results in another call to the backend API. If the data doesn‚Äôt change that much, no need to keep getting the data. Instead of manually implementing a cache, with NgRx, the store can hold the data intead.</p>

<h3 id="complex-component-interactions">Complex component interactions</h3>

<p>Without NgRx, a user interaction can result in multiple components needing to be updated. May need to closely couple the components in order to ensure all components correctly get the information required. With NgRx when a user selects a product, the component dispatches an action with the current product as the payload. The reducer uses this, with the current state to create new state. The store retains the current product. Any component can subsribe to the current product selectors to receive changes in state. This decouples the component from each other. The components are also decoupled from the store. They don‚Äôt update the store, but instead dispatch actions, in turn used by reducers to update the store. Components don‚Äôt read from the store, the subscribe to the store via a selector to receieve state change notifications. The state is the single source of truth</p>

<h3 id="tooling">Tooling</h3>

<p>Has good debug tooling for troubleshooting.</p>

<h3 id="dont-use-ngrx-if">Don‚Äôt use NgRx if</h3>

<ul>
  <li>New to Angular - concentrate on Angular and RxJS Observables first</li>
  <li>Simple application - extra code probably not worth it</li>
  <li>Team already has a good pattern - no need to change if a good state management pattern is already in place</li>
</ul>

<h1 id="sample-application">Sample Application</h1>

<p><img src="https://www.dropbox.com/s/qcrk6w5hxjyjkfa/pluralsight-sample-application-architecture.png?raw=1" alt="Sample Application" /></p>

<h1 id="the-redux-pattern">The Redux Pattern</h1>

<ul>
  <li>This pattern is implemented in almost all front end frameworks: React has Redux (the library); Vue has Vux; Angular has NgRx</li>
  <li>A predictable state container for JS applications</li>
  <li>Redux, the library, was the first to implement the pattern, was based on Facebook‚Äôs lux library and is now the dominant state management pattern for SPAs</li>
</ul>

<h2 id="characteristics">Characteristics</h2>

<ul>
  <li>Single source of truth</li>
  <li>State is read only - only way to change it is to dispatch an action</li>
  <li>Changes to the store are made using reducers using pure functions</li>
</ul>

<h2 id="different-parts">Different parts</h2>

<ul>
  <li>The store is simply a JS object</li>
  <li>Example actions: Login action (after a login form submission); Toggle side menu action (after a button click); Retrive data action (on initialisation of a component); Start a global spinner action (when saving data)</li>
  <li>Actions are JS objects with a <code class="highlighter-rouge">type</code> (string) and (optional) <code class="highlighter-rouge">payload</code> (any type) e.g.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  type: 'LOGIN',
  payload: {username: 'duncan', password: 'secret'}
}
</code></pre></div>    </div>
  </li>
  <li>Example reducers (change the state): Set <code class="highlighter-rouge">userDetails</code> property (on login); Toggle <code class="highlighter-rouge">sideMenuVisible</code> property to true on button click; Set successfully retrieved data on component initialization; Set <code class="highlighter-rouge">globalSpinnerVisible</code> property true while saving data</li>
  <li>Not all dispatched actions can update the store via a reducer, since some actions have side effects. Side effects are managed using NgRx Effects library</li>
  <li>Reducers are pure functions i.e. no side effects and don‚Äôt depend on anything outside of the function</li>
  <li>Advantages include:
    <ul>
      <li>centralized immutable state, repeatable trail of state changes</li>
      <li>Using pure functions to change state enables time travel debugging, record / replay / hot reloading</li>
      <li>Easy to rehydrate application state from storage</li>
      <li>Easier to implement Angular change detection strategy called OnPush</li>
      <li>Writing unit tests easier. Good tooling (history of state changes etc)</li>
      <li>Simpler component communication.</li>
    </ul>
  </li>
</ul>

<h1 id="first-look-at-ngrx">First Look at NgRx</h1>

<p>The sample application makes use of Angular in-memory-web-api https://github.com/angular/in-memory-web-api. This is the same library used by the Angular documentation. It supports basic CRUD operations. 
Often a good idea to layout out the store in a hierarchy e.g. following the feature modules in an application. Each feature section of JSON is sometimes known as a <strong>slice</strong>.</p>

<p>In the <code class="highlighter-rouge">AppModule</code> add an import to <code class="highlighter-rouge">StoreModule</code> and in the <code class="highlighter-rouge">imports</code> array add the <code class="highlighter-rouge">StoreModule</code> calling the <code class="highlighter-rouge">forRoot</code> method and passing in the root reducer i.e. <code class="highlighter-rouge">StoreModule.forRoot(reducer)</code> This associates the reducer with the store and registers the state container with the application. There will be multiple reducers for each area of the application e.g. <code class="highlighter-rouge">Root Reducer</code>, <code class="highlighter-rouge">Products Reducer</code>, <code class="highlighter-rouge">Users Reducer</code> etc. This makes it easier to build, maintain and test. Also state is not created for a module which is not loaded.</p>

<p>Feature Module State Composition - allow composing application state from feature module reducers. Add additional reducers to each feature module using <code class="highlighter-rouge">StoreModule.forFeature('products', reducer)</code> where ‚Äòproducts‚Äô is the name of the feature slice and the reducer which manages that feature‚Äôs slice of state. Repeat this for all modules using the store.</p>

<p>Note. All looks very similar to router code e.g.  <code class="highlighter-rouge">RouterModule.forRoot(appRoutes)</code> and <code class="highlighter-rouge">RouterModule.forChild(productRoutes)</code>.</p>

<p>Can furthermore defines even fine grained reducers for sub slices of state e.g. <code class="highlighter-rouge">Product List Reducer</code> and <code class="highlighter-rouge">Product Data Reducer</code>. These reducers are aggregated for their associated feature. Useful when a single feature has a lot of state. Initialisation in this scenario:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>StoreModule.forFeature('products',
    {
        productList: listReducer,
        productData: dataReducer
    }
)
</code></pre></div></div>

<p>When dealing with reducers which only work on slices, only the slice of data is sent to the reducer. The reducer takes and copy, applies any changes and then replaces this slice back in the store. There is no mechanism to stop code updating the store directly, need to stick to the patterns. IF wanting something explicit, could use e.g. <code class="highlighter-rouge">ngrx-store-freeze library</code>.</p>

<p>To subscribe to state changes either use the stores <code class="highlighter-rouge">select</code> method e.g. <code class="highlighter-rouge">this.store.select('products')</code> OR since the store is an observable can instead use the pipe method and the ngrx <code class="highlighter-rouge">select</code> operator: <code class="highlighter-rouge">this.store.pipe(select('products'))</code>. The advantage of the operator is that we can add further pipeable operators as needed to shape the results required by the component.</p>

<p>Both the select method and the select operator return a slice of state as an observable. To be notified of changes to the state, subscribe to this observable. i.e. <code class="highlighter-rouge">this.store.pipe(select('products')).subscribe(products =&gt; this.displayCode = products.showProductCode);</code>. This gets the WHOLE slice of state and can be improved (later). The first argument to the subscribe method is a ‚Äúnext‚Äù function.</p>

<p>Need to also unsubscribe from observables in the ngOnDestroy method. One way is to keep track of the subscription in a variable. However using effects is a better way (unsubscribe strategies later).</p>

<p>Don‚Äôt track events local to a component, unless those events change data which must be tracked after the component is destroyed.</p>

<p>Actions are passed to ALL reducers and processed by any matching case statements.</p>

<p>Subscribing to the store is often done in ngOnInit.</p>

<h1 id="developer-tools-and-debugging">Developer Tools and Debugging</h1>
<h1 id="strongly-typing-the-state">Strongly Typing the State</h1>
<h1 id="strongly-typing-actions-with-action-creators">Strongly Typing Actions with Action Creators</h1>
<h1 id="working-with-effects">Working with Effects</h1>
<h1 id="performing-update-operations">Performing Update Operations</h1>
<h1 id="architectural-considerations">Architectural Considerations</h1>
<h1 id="final-words">Final Words</h1>
:ET