I"Ö<h2 id="learning-the-basics-of-the-polly-framework">Learning the Basics of the Polly Framework</h2>

<h3 id="resilience-strategies">Resilience strategies</h3>

<ul>
  <li>Reactive - responds to a current problem
    <ul>
      <li>Retry - retries immediately</li>
      <li>Wait and retry - wait before sending retry request</li>
      <li>Circuit breaker - stop all requests to a fault service</li>
      <li>Fallback - return default value (if request fails) - often used in combination with other policies</li>
    </ul>
  </li>
  <li>Proactive - monitors for potential problems and acts ahead
    <ul>
      <li>Timeout - set a specific timeout rather than waiting for the default from the HttpClient</li>
      <li>Caching - store a previous response and serve this</li>
      <li>Bulkhead isolation - limit number of requests and queue of waiting requests</li>
    </ul>
  </li>
</ul>

<h3 id="retry-policy">Retry Policy</h3>

<p>There are 2 parts: handler part - what to check for and the behaviour part - what to do if the criteria is met. A delegate can also be called prior to each retry.</p>

<p>NOTE: not recommended to instantiate in the constructor of the controller.. Better ways to share across controllers and across projects.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>readonly RetryPolicy&lt;HttpResponseMessage&gt; _httpRetryPolicy;

public CatalogController()
{
    _httpRetryPolicy = Policy.HandleResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode).RetryAsync(3, onRetry: (response, timespan) =&gt;
    {
        if (response.Result.StatusCode == HttpStatusCode.Unauthorized)
        {
            PerformReauthorisaction();
        }
    });
}

public Task&lt;IActionResult&gt; GetOrders()
{
    // calling the remote service
    var response = await _httpRetryPolicy.ExecuteAsync(() =&gt; _httpClient.GetAsync(_endpoint));
}
</code></pre></div></div>

<p>NOTE: The <code class="highlighter-rouge">IAsyncPolicy</code> is useful for unit testing, but otherwise the concrete types are simpler for demonstration purposes</p>

<h3 id="wait-and-retry-policy">Wait and Retry Policy</h3>

<p>Wait before the next retry and also allow increasing the backoff between each subsequent request e.g. Ethernet uses an exponential backoff when collisions occur.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.WaitAndRetryAsync(3, retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)/2))
</code></pre></div></div>

<p>Can additionally add jitter i.e. randomness so that not all services are backing off and retrying at exactly the same time</p>

<h3 id="fallback">Fallback</h3>

<p>Additionally declare a fallback policy and a meaningful default which the policy will return. Then wrap the currently wrapped call again.</p>

<p><code class="highlighter-rouge">var response = await _httpFallbackPolicy.ExecuteAsync(() =&gt; _httpRetryPolicy.ExecuteAsync(() =&gt; _httpClient.GetAsync(_endpoint)));</code></p>

:ET