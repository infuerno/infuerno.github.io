I"ú3<h2 id="chapter-1-data-portal-deployment">Chapter 1: Data Portal Deployment</h2>

<p>Supports 1-, 2-, 3-, 4- tier deployments. CSLA is comprised of 5 logical layers: Interface, Interface Control, Business Logic, Data Access, Data Storage and Management. These 5 layers can be deployed physically into various configurations.</p>

<p>The data portal manages the movement of objects between the Business layer running on the ‚Äúclient‚Äù and the Business layer running on the ‚Äúserver‚Äù. The Business layer therefore needs to be deployed to both.</p>

<p>The Local channel (local proxy) does not cross the network. Both server and client side components are run within the same AppDomain.</p>

<p>The other channels at the very least cross AppDomain or process boundaries.</p>

<p>The WCF channel for .NET uses the <code class="highlighter-rouge">NetDataContractSerializer</code> provided by WCF. Any binding which uses synchronous communication can be used (i.e. not MSMQ, but HTTP, TCP, named pipes all ok).</p>

<p>‚ÄúProxy‚Äù on the ‚ÄúClient‚Äù. ‚ÄúHost‚Äù on the ‚ÄúServer‚Äù. The data portal proxy on the client side loads the proxy based on the <code class="highlighter-rouge">CslaDataPortalProxy</code> configuration setting. The proxy in turn invokes the host (often running within IIS), and the host the server side components.</p>

<h3 id="3-tier-deployment">3-tier Deployment</h3>

<p>Possible to use 3-tier deployment model for a web application - isolating the web server from the organisation‚Äôs internal network.</p>

<ul>
  <li>Browser - Interface</li>
  <li>Web server - Interface Control and Business Logic</li>
  <li>App server - Business Logic and Data Access</li>
  <li>SQL server - Data Storage and Management</li>
</ul>

<p>The data portal is configured to run in <em>remote</em> mode, WCF channel is recommended.</p>

<h3 id="using-the-local-channel">Using the Local Channel</h3>

<p>The <code class="highlighter-rouge">CslaDataPortalProxy</code> is set to <code class="highlighter-rouge">Local</code> by default so explicit configuration (AppSetting) is not required.</p>

<p>Objects are nevertheless serialized and deserialized which incurs some overhead. ALL KINDS OF SIDE EFFECTS - NOT RECOMMENDED unless you are willing to write extra application code to deal with certain new scenarios this will introduce.</p>

<h3 id="using-the-wcf-channel">Using the WCF Channel</h3>

<p>A WCF Channel consists of a <code class="highlighter-rouge">WcfProxy</code> class running on the client and a <code class="highlighter-rouge">WcfPortal</code> class running on the server (which uses WCF under the hood). Three primary elements define the connection on both the client and the server: Address, Binding and Contract. e.g. example client configuration:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;client&gt;
&lt;endpoint name="BasicHttpBinding_IWcfPortal" address="http://localhost:21647/SlPortal.svc" binding="basicHttpBinding" contract="WcfPortal.IWcfPortal" /&gt;
&lt;/client&gt;
</code></pre></div></div>

<dl>
  <dt>: Address</dt>
  <dt>Address where the service is hosted</dt>
  <dd>
    <p>Binding
The address will depend on the binding used. Serveral bindings use HTTP, but also TCP sockets, named pipes (all synchronous) and MSMQ queues (async).
e.g. tcp binding: <code class="highlighter-rouge">tcp://myserver.mycompany.com:12004/WcfPortal.svc</code></p>
  </dd>
  <dt><em>The data portal needs SYNCHRONOUS bindings.</em></dt>
  <dd>
    <p>Contract</p>
  </dd>
</dl>

<p>Defines operation contract - methods a service implements; data contracts - properties or parameters for the methods; fault contracts - messages returned in event of failure. When using the WCF data portal channel, the service contract is defined by CSLA .NET. The .NET contract (as opposed to the Silverlight one) is <code class="highlighter-rouge">IWcfPortal</code> from the <code class="highlighter-rouge">Csla.Server.Hosts</code> namespace.</p>

<h4 id="customisations">Customisations</h4>

<ul>
  <li>WCF message size limits on the server need to be increased to transfer the object graphs - at least 6 different attributes which may need to be increased on the server binding</li>
  <li>ASP.NET and IIS size limits also need increasing e.g. <code class="highlighter-rouge">&lt;httpRuntime maxRequestLength="2147483647"/&gt;</code></li>
  <li>WCF size limits on the client may also need to be increased, as well as send and receive timeouts</li>
  <li>Return faults by setting a custom behaviour on the server (required for the data portal to operate correctly)</li>
</ul>

<h4 id="troubleshooting">Troubleshooting</h4>

<ul>
  <li>WCF can be configured to write detailed information to a .NET trace listener using <code class="highlighter-rouge">system.diagnostics</code> configuration element</li>
</ul>

<h4 id="net-client-configuration">.NET Client Configuration</h4>

<ol>
  <li>Configuration to use the WCF Channel is by the <code class="highlighter-rouge">CslaDataPortalProxy</code> app setting:
<code class="highlighter-rouge">&lt;add key="CslaDataPortalProxy" value="Csla.DataPortalClient.WcfProxy, Csla" /&gt;</code></li>
  <li>URL of the server e.g. using the <code class="highlighter-rouge">CslaDataPortalUrl</code> app setting (uses wsHttpBinding with maximum message sizes) OR explicity specify the client WCF binding with endpoint name WcfDataPortal OR explicity in code.</li>
</ol>

<h4 id="server-configuration-iis-and-aspnet">Server Configuration (IIS and ASP.NET)</h4>

<p>Any ASP.NET web project which can run in IIS. The following references must be added:</p>

<ul>
  <li>Csla.dll</li>
  <li>Business libraries</li>
  <li>Data access libraries</li>
  <li>Any other libraries required by the server side code</li>
</ul>

<p>WcfPortal.svc file is the endpoint for the .NET data portal and contains a line detailing the type which implements the service (and nothing else).</p>

<ol>
  <li>Configure an application in IIS</li>
  <li>Increase the ASP.NET maximum request lengths (as per customisations above)</li>
  <li>Add WCF serviceModel configuration section as detailed</li>
</ol>

<h2 id="chapter-2-data-portal-configuration-reference">Chapter 2: Data Portal Configuration Reference</h2>

<p>List of all the appSettings that can be applied either client or server side for the data portal.</p>

<h2 id="chapter-3-serialization">Chapter 3: Serialization</h2>

<p>Standard .NET serializer with 100% fidelity is <code class="highlighter-rouge">NetDataContractSerializer</code> (NDCS) replacing the previous <code class="highlighter-rouge">BinaryFormatter</code>. Although WCF defaults to the NDCS, CSLA defaults to the <code class="highlighter-rouge">BinaryFormatter</code> ‚Äúfor all operations outside the channel‚Äù - what does this mean? Does it use it or not? The <code class="highlighter-rouge">CslaSerializationFormatter</code> can use used to override the default.</p>

<h2 id="chapter-4-custom-data-portal-proxies">Chapter 4: Custom Data Portal Proxies</h2>

<p>Useful for advanced scenarios.</p>
<ul>
  <li>Client proxy has a couple of use cases when a custom data portal proxy implementation may be required e.g. multiple server hosts (covered in further detail in this section)</li>
  <li>Custom server host implementations are rare - on your own for this</li>
</ul>

<h2 id="chapter-5-authentication-models">Chapter 5: Authentication Models</h2>

<p>In .NET the principal object is attached to the current thread or <code class="highlighter-rouge">HttpContext</code> object. CSLA.NET supports 3 authentication models:</p>

<ol>
  <li>Custom authentication</li>
  <li>ASP.NET Memberhip Provider authentication</li>
  <li>Windows authentication</li>
</ol>

<h3 id="custom-authentication">Custom Authentication</h3>

<p>Use custom authentication when you want to authenticate users against your own database, LDAP etc rather than using their windows credential. To implement a custom principal - generally only need to implement Login and Logout operations.</p>

<h4 id="custom-principal">Custom Principal</h4>

<ul>
  <li><code class="highlighter-rouge">BeginLogin</code> and <code class="highlighter-rouge">Login</code> methods take username and password, but details will vary depending on how you need to authenticate</li>
  <li>Both example methods invoke factory methods on the custom identity class</li>
  <li>No exception is thrown if the username or password is incorrect - the identity object returned will have <code class="highlighter-rouge">IsAuthenticated</code> set to false and the principal will contain no roles.</li>
  <li><code class="highlighter-rouge">Load</code> method only requires the username - used by e.g. ASP.NET to load the principal on each request once already authenticated (by calling an equivalent method on the custom identity class)</li>
</ul>

<h4 id="custom-identity">Custom Identity</h4>

<ul>
  <li>Adding lots of properties to the custom identity has a performance impact
    <ul>
      <li>either add to a custom object on the LocalContext dictionary class (doesn‚Äôt flow through)</li>
      <li>or load each time on the application server</li>
    </ul>
  </li>
  <li>Identity data access code needs to
    <ul>
      <li>verify identity</li>
      <li>load roles</li>
      <li>load any extra profile</li>
    </ul>
  </li>
</ul>

<h4 id="application-server-configuration">Application Server Configuration</h4>

<p>Discussion of how to implement loading the principal on the server EACH TIME</p>

<h4 id="client-application-configuration---aspnet-applications">Client Application Configuration - ASP.NET Applications</h4>

<p>ASP.NET provides support for authentication, including managing an encrypted user token in a cookie (or URL). The encrypted token minimally contains the username and the expiration time and (optionally contains roles, but not usually due to cookie size). ASP.NET creates a principal and identity from the authentication token, but this is minimal and doesn‚Äôt contain roles or any other profile attributes. The <code class="highlighter-rouge">CustomPrincipal</code> required by the application needs to be make available for each request.</p>

<ul>
  <li>Stateless applications - use the username from the authentication token (ASP.NET out of the box identity) to load the principal using the <code class="highlighter-rouge">Load</code> method of the <code class="highlighter-rouge">CustomPrincipal</code>.</li>
  <li>Stateful applications - keep the principal in Session - may or may not provide better performance</li>
</ul>

<p>In the <code class="highlighter-rouge">Application_AcquireRequestState</code> in the <code class="highlighter-rouge">Global.asax.cs</code> the real custom principal loaded via <code class="highlighter-rouge">CustomPrincipal.Load()</code> (which in turn sets the <code class="highlighter-rouge">Csla.ApplicationContext.User</code>) or via <code class="highlighter-rouge">CustomPrincipal.Login()</code></p>

<h3 id="membership-provider-authentication">Membership Provider Authentication</h3>

<p><code class="highlighter-rouge">CustomPrincipal</code> is same as above. <code class="highlighter-rouge">CustomIdentity</code> is similar. The data access is implemented using the ‚Äúencapsulated invoke model‚Äù (see Data Access book).</p>

<ul>
  <li>Data access code uses types from System.Web.Security - FULL .NET FRAMEWORK.</li>
  <li>However <code class="highlighter-rouge">Library.Net</code> targets the Client Profile - WHY? So to workaround the DAL provider needs to be DYNAMICALLY loaded.</li>
  <li>A DalManager is used to dynamically load these types.</li>
  <li>DataPortal_Fetch methods in the CustomIdentity call the DalManager to get the dynamically loaded implementation of the dal (IIdentityDal)</li>
  <li>The IIdentityDal wraps calls to the MembershipProvider</li>
  <li>Two calls are made to membership <code class="highlighter-rouge">Membership.VerifyUser(u, p)</code> and then <code class="highlighter-rouge">Membership.GetUser(u)</code> - HOW DOES THE INCREMENT / AUTO LOCK OUT WORK</li>
  <li>GetRolesForUser uses <code class="highlighter-rouge">Roles.Provider.GetRolesForUser</code> rather than <code class="highlighter-rouge">Roles.GetRolesForUser</code> due to a bug presumably in .NET 4 - how do we specify the Application here? Rather than have to define two / three different connection strings and therefore providers?</li>
</ul>

<h3 id="windows-authentication">Windows Authentication</h3>

<p>For ASP.NET applications using CSLA, the application must simply be configured not to perform any explicity authentication or impersonation</p>

<p>Why do we need to use ASP.NET membership? We simply need to store or update the id_token / user profile. From the graph API this has a distinct set of fields, and any custom ones can go into a custom table‚Ä¶?</p>

<p>BUT if we then need to support BOTH with ASP.NET membership AND without it??</p>

<p>We DO need to ensure that CSLA membership principal is instantiated properly from the regular Principal</p>

<p>Use the Membership Roles Provider with Windows Authentication.
Screens to administer will still remain within MABO (along with Q1, Q2)</p>
:ET