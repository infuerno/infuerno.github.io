I"E<p>##Chapter 1 Cocoa: What is it?</p>

<p>Objective C reference on Apple site: &lt;http://developer.apple.com/library/mac/#d
ocumentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduct
ion.html#//apple_ref/doc/uid/TP40011210&gt;</p>

<p>##Chapter 2 Let’s Get Started</p>

<ul>
  <li><strong>Outlet</strong> - instance variable which is a pointer to another object</li>
  <li><strong>Action</strong> - method that can be triggered by user interface objects</li>
  <li><strong>Set the outlet of an object</strong> - control drag from the object that needs to know to the object it needs to know about</li>
  <li>Navigate -&gt; Jump to Next Counterpart command, Control-Command-UpArrow, flips the editor between corresponding <code class="highlighter-rouge">.h</code> and <code class="highlighter-rouge">.m</code> files. </li>
</ul>

<p>##Chapter 3 Objective-C
###Allocating memory
Create a new instance of <code class="highlighter-rouge">NSMutableArray</code> by sending the message
<code class="highlighter-rouge">alloc</code> to the <code class="highlighter-rouge">NSMutableArray</code> class:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[NSMutableArray alloc];
</code></pre></div></div>
<p>###Sending messages
Send the message init to the object foo points to, “foo is the receiver of the
message init”:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[foo init];
</code></pre></div></div>

<p>Messages can be nested. The method init returns the newly initialised object, so message sends must always be initialised like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo = [[NSMutableArray alloc] init];
</code></pre></div></div>

<p>To differentiate between constant C strings and constant <code class="highlighter-rouge">NSString</code>s, you
must put <code class="highlighter-rouge">@</code> before the opening quote of a constant <code class="highlighter-rouge">NSString</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSLog(@"The number at index %d is %@", i, numberToPrint);
</code></pre></div></div>

<p>Arguments are specified using a colon:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[foo addObject:bar];
</code></pre></div></div>

<p>Multiple arguments use different parts of the selector (or method name). In this case the selector is insertObject:atIndex:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[foo insertObject:bar atIndex:5];
</code></pre></div></div>

<p>###NSArray
List of pointers to other objects, indexed by integers, cannot contain nil, is immutable (NSString and NSNumber are also immutable.) One array can hold objects of different classes. It can’t hold C primitive types e.g. int, float.</p>

<p>###Initialisers</p>
<ul>
  <li>You do not have to create any initializer in your class if the superclass’s initializers are sufficient</li>
  <li>If you decide to create an initializer, you must override the superclass’s designated initializer.</li>
  <li>If you create multiple initializers, only one does the work—the designated initializer. All other initializers call the designated initializer.</li>
  <li>The designated initializer of your class will call its superclass’s designated initialiser.</li>
</ul>

<p>If a class initialiser always requires an argument, override the base class init method to throw an exception.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (id)init
{
    @throw [NSException exceptionWithName:@"BNRBadInitCall"
                 reason:@"Initialize Lawsuit with initWithDefendant:"
               userInfo:nil];
    return nil;
}
</code></pre></div></div>

<p>###The debugger
A handy feature is the “print object” <code class="highlighter-rouge">po</code>. Calling <code class="highlighter-rouge">po</code> on an object will send the message <code class="highlighter-rouge">description</code> to the object.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>po newEntry
</code></pre></div></div>

<p>The debugger can be configured to stop whenever an exception is thrown by “adding an exception breakpoint” from the breakpoint navigator.</p>

<p>Use <code class="highlighter-rouge">NSAssert()</code> to throw an exception as soon as the program is in an unstable state e.g. a variable is unexpectedly nil. Note: this only works in Objective-C methods. Use <code class="highlighter-rouge">NSCAssert()</code> in C methods.</p>

<p>Set the preprocessor macro for release mode <code class="highlighter-rouge">NS_BLOCK_ASSERTIONS</code> to ensure an exception is not thrown in release mode.</p>

<p>###Static Analyzer
The static analyzer (Product &gt; Analyze) shows potential problems with the code over and above compiler warnings and errors.</p>

<p>##Chapter 4 Memory Management
When an object is no longer used i.e. no longer has any pointers to it, the memory can be reused. Working out which memory is available for reuse is tricky.</p>

<p>Three solutions (with advantages and disadvantages) are:</p>

<ol>
  <li>Manual reference counting or retain counts. Every object has a retain count which is the number of objects with pointers to it. When the retain count of an object is 0 it is deallocated.
    <ul>
      <li>Requires explicit programming statements.</li>
      <li>Retain cycles possible (two objects reference each other but not referenced by anything else).</li>
    </ul>
  </li>
  <li>Garbage collection. Unreachable objects are automatically deallocated.
    <ul>
      <li>Performance cost - poorer or uneven performance while the GC scans the object collection</li>
      <li>Cannot manage manually allocated memory e.g. allocated with <code class="highlighter-rouge">malloc</code></li>
      <li>GC not supported on Mac OS X &lt; 10.5 or iOS</li>
    </ul>
  </li>
  <li>ARC - automatic reference counting. Retain count mechanism is used, but is managed by the compiler rather than explicitly by programmers.
    <ul>
      <li>Doesn’t require explicit programming statements to manage retain counts</li>
      <li>Doesn’t have GC performance hit</li>
      <li>Still needs work to avoid retain cycles</li>
      <li>Doesn’t manage manually allocated memory</li>
    </ul>
  </li>
</ol>

<p>###Manual reference counting
When an object is created using alloc, the retain count is 1. Retain count is incremented by sending the <code class="highlighter-rouge">retain</code> message and deallocated by sending the <code class="highlighter-rouge">release</code> message.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSDate *now = [[NSDate alloc] init];

/* lines of code which use the variable now */

[now release]
</code></pre></div></div>

<p>When creating objects and adding them to an array, the array stores a pointer to the object and sends it a message <code class="highlighter-rouge">retain</code>. The retain count is incremented. When the array is deallocated it sends <code class="highlighter-rouge">release</code> messages to the objects it contains. The object’s retain counts are decremented, but will still be 1. Therefore the objects should be sent a <code class="highlighter-rouge">release</code> message after adding to the array.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cat \*cat = [[Cat alloc] initWithBreed:breed];
[array addObject:cat];
[cat release];
</code></pre></div></div>

<p>The <code class="highlighter-rouge">array</code> now has ownership of <code class="highlighter-rouge">cat</code>.</p>

<p>Objects will often <code class="highlighter-rouge">retain</code> objects they hold references to. If an object is passed into a constructor the <code class="highlighter-rouge">retain</code> message will be sent to it and similarly a <code class="highlighter-rouge">release</code> message sent in the destructor <code class="highlighter-rouge">dealloc</code>.</p>

<p>If overriding the <code class="highlighter-rouge">dealloc</code> method, call <code class="highlighter-rouge">[super dealloc]</code> at the <em>end</em>.</p>

<p>###Autoreleasing objects
When a method creates and object and returns a pointer to that object we don’t want to <code class="highlighter-rouge">retain</code> the object. But if we <code class="highlighter-rouge">release</code> it before returning, there will be no object to return. To resolve this use the autorelease pool by sending the object the <code class="highlighter-rouge">autorelease</code> message. The release message is sent to all objects in the autorelease pool when the pool is drained. In Cocoa an autorelease pool is created before an event and drained after the event has been handled. Autorelease pools can also be created explicitly in non-event driven applications, or to more explicitly manage memory.</p>

<p>Many methods return autoreleased objects. e.g. <code class="highlighter-rouge">NSString initWithFormat</code> doesn’t, but the class method <code class="highlighter-rouge">NSString stringWithFormat</code> does.</p>

<p>From stackoverflow <a href="http://stackoverflow.com/questions/1378206/do-all-class-methods-return-an-autoreleased-object">http://stackoverflow.com/questions/1378206/do-all-class-methods-return-an-autoreleased-object</a>:</p>

<blockquote>
  <p>Class methods, just like instance methods, should adhere to the standard Cocoa memory management rules.</p>
</blockquote>

<blockquote>
  <blockquote>
    <p>You take ownership of an object if you create it using a method whose name begins with “alloc” or “new” or contains “copy” (for example, alloc, newObject, or mutableCopy), or if you send it a retain message. You are responsible for relinquishing ownership of objects you own using release or autorelease. Any other time you receive an object, you must not release it.</p>
  </blockquote>
</blockquote>

<blockquote>
  <p>Presumably they are returning an autoreleased object, or a reference to a singleton or something like that. Either way, you need not release the object unless it started with “alloc” or “new” or contained “copy”. You need not retain it unless you’re looking to keep it around past the scope of the current autorelease pool, by storing it in an iVar or something like that.</p>
</blockquote>

<p>###The retain count rules</p>
<ul>
  <li>If you create an object by using a method whose name starts with <code class="highlighter-rouge">alloc</code> or <code class="highlighter-rouge">new</code> or contains <code class="highlighter-rouge">copy</code>, you have taken ownership of it.</li>
  <li>An object created through any other means, such as a convenience method, is not owned by you.</li>
  <li>If you don’t own an object and want to ensure its continued existence, take ownership by sending it the message <code class="highlighter-rouge">retain</code>.</li>
  <li>When you own an object and no longer need it, send it the message <code class="highlighter-rouge">release</code> or <code class="highlighter-rouge">autorelease</code>.</li>
  <li>As long as it has at least one owner, an object will continue to exist.</li>
</ul>

<p>Finally, think locally and trust that all other code is doing the right thing</p>

<p>###Strong and weak references
By default all references are strong. ARC will take care of releasing strong references.</p>

<p>Retain cycles need to be managed properly by strategically using weak references. A typical example is where a class holds references to both parents and children. The pattern commonly used in Objective-C is to leave the parent-child relationship strong, but make the child-parent relationship weak:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@interface Person : NSObject {
    __weak Person *parent; // Good! No strong reference cycle.
    NSMutableArray *children;
}
@end
</code></pre></div></div>

<p>###ARC
Under ARC it is an error to use the manual retain count functionality. That is, you can’t send the messages <code class="highlighter-rouge">retain</code>, <code class="highlighter-rouge">release</code>, <code class="highlighter-rouge">autorelease</code>, <code class="highlighter-rouge">dealloc</code>.</p>

<p>###Chapter 5 Target/Action</p>

<p>###Chapter 6 Helper Objects
Functionality of objects in the Cocoa framework are often extended using helper objects. For example a table view is supplied with a helper object to supply the data.</p>

<p>####Delegates
Many classes in the Cocoa framework have an instance variable called <code class="highlighter-rouge">delegate</code> to point to a helper object. If your class is to be the delegate, then change the class declaration to refer to this protocol:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@interface SpeakLineAppDelegate : NSObject    &lt;NSApplicationDelegate, NSSpeechSynthesizerDelegate&gt; {
</code></pre></div></div>

<p>Additionally set the delegate outlet  of the speech synthesizer with <code class="highlighter-rouge">[_speechSynth setDelegate:self]</code> in <code class="highlighter-rouge">init</code>.</p>

<p>####NSTableView and its dataSource
<code class="highlighter-rouge">NSTableView</code> has a helper object called <code class="highlighter-rouge">dataSource</code>. The NSTableView dataSource object needs to conform to the NSTableDataSource informal protocol i.e. has to have some methods to give data. <code class="highlighter-rouge">NSTableView</code> also has a helper object called <code class="highlighter-rouge">delegate</code>.</p>

<p>####Finding delegate methods at runtime
If you wanted to see the checks for the existence of the delegate methods, you could override respondsToSelector: in your delegate object:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (BOOL)respondsToSelector:(SEL)aSelector{
	NSString *methodName = NSStringFromSelector(aSelector);
	NSLog(@"respondsToSelector:%@", methodName);
	return [super respondsToSelector:aSelector];
}
</code></pre></div></div>

<p>###Chapter 7 Key-Value Coding and Key-Value Observing
Key-value coding (or KVC) is a mechanism that allows you to set and get the value of any variable by its name. Alternatively you can declare getter and setter methods. These will use the KVC methods as long as the naming convention for getters and setters is followed.</p>

<p>####Bindings
Graphical objects can be bound to keys - the view will automatically keep the values in sync.</p>

<p>If the value of the object is changed directly, any observers are not notified of the change. Explicityly trigger the notification of the observers with:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[self willChangeValueForKey:@"fido"];
// action
[self didChangeValueForKey:@"fido"];
</code></pre></div></div>

<p>####Properties
If simple setters and getters are required, properties can be declared instead:</p>

<ul>
  <li><code class="highlighter-rouge">@property (readwrite, assign) int fido;</code> in the header file;</li>
  <li><code class="highlighter-rouge">@synthesize fido</code> in the implementation file</li>
</ul>

<p>####Attributes of a property</p>
<ul>
  <li><code class="highlighter-rouge">readwrite</code> or <code class="highlighter-rouge">readonly</code></li>
  <li><code class="highlighter-rouge">assign</code>, <code class="highlighter-rouge">strong</code>, <code class="highlighter-rouge">weak</code> or <code class="highlighter-rouge">copy</code> where <code class="highlighter-rouge">assign</code> is used for non-pointer types</li>
  <li><code class="highlighter-rouge">nonatomic</code> can be used to explicitly eliminate the overhead of using locks to ensure atomic setters</li>
</ul>

<p>####Key paths</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSString *mn;
mn = [selectedPerson valueForKeyPath:@"spouse.scooter.modelName"];

NSNumber *theAverage;
theAverage = [employees valueForKeyPath:@"@avg.expectedRaise"];
</code></pre></div></div>

<p>Other commonly used operators:</p>

<ul>
  <li>\@avg</li>
  <li>\@count</li>
  <li>\@max</li>
  <li>\@min</li>
  <li>\@sum</li>
</ul>

<p>###Chapter 8 NSArray Controller
Controller classes in the MVC design pattern are usually application specific and used with more general-purpose Views and Models.
<code class="highlighter-rouge">NSController</code> is an abstract class, with <code class="highlighter-rouge">NSObjectController</code>displaying the content of an object. <code class="highlighter-rouge">NSArrayController</code> further derives from this to display the contents of an array.
Model classes need only import <code class="highlighter-rouge">Foundation/Foundation.h</code></p>

<p>###Chapter 9</p>

<p>###Chapter 10</p>

<p>###Chapter 11</p>

<p>###Chapter 12</p>

<p>###Chapter 13</p>

<p>###Chapter 14</p>

<p>###Chapter 15</p>

<p>###Chapter 16</p>

<p>###Chapter 17</p>

<p>###Chapter 18</p>

<p>###Chapter 19</p>

<p>###Chapter 20</p>

<p>###Chapter 21</p>

<p>###Chapter 22</p>

<p>###Chapter 23</p>

<p>###Chapter 24</p>

<p>###Chapter 25</p>

<p>###Chapter 26</p>

<p>###Chapter 27</p>

<p>###Chapter 28</p>

<p>###Chapter 29</p>

<p>###Chapter 30</p>

<p>###Chapter 31</p>

<p>###Chapter 32</p>

<p>###Chapter 33</p>

<p>###Chapter 34</p>

<p>###Chapter 35</p>

<p>###Chapter 36</p>

<p>###Chapter 37</p>

<p>###Chapter 38 The End</p>

:ET