I"0<h1 id="introduction">Introduction</h1>

<ul>
  <li>Ellen Ullman, Close to the Machine: Technophilia and its Discontents</li>
  <li>Ursula K. Le Guin, The Left Hand of Darkness</li>
</ul>

<h1 id="chapter-1-values-types-and-operators">Chapter 1. Values, Types, and Operators</h1>

<p>Backtick-quoted strings, usually called template literals, can do a few more tricks. Apart from being able to span lines, they can also embed other values.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>`half of 100 is ${100 / 2}`
</code></pre></div></div>
<p>When you write something inside <code class="highlighter-rouge">${}</code> in a template literal, its result will be computed, converted to a string, and included at that position. The example produces ‚Äúhalf of 100 is 50‚Äù.</p>

<p>There are two special values, written <code class="highlighter-rouge">null</code> and <code class="highlighter-rouge">undefined</code>, that are used to denote the absence of a meaningful value. They are themselves values, but they carry no information.<br />
Many operations in the language that don‚Äôt produce a meaningful value (you‚Äôll see some later) yield <code class="highlighter-rouge">undefined</code> simply because they have to yield some value.<br />
The difference in meaning between <code class="highlighter-rouge">undefined</code> and <code class="highlighter-rouge">null</code> is an accident of JavaScript‚Äôs design, and it doesn‚Äôt matter most of the time. In cases where you actually have to concern yourself with these values, I recommend treating them as mostly interchangeable.</p>

<h1 id="chapter-2-program-structure">Chapter 2. Program Structure</h1>
<p>You should imagine bindings as tentacles, rather than boxes.</p>

<p>A binding name may include dollar signs ($) or underscores (_) but no other punctuation or special characters. Words with a special meaning, such as let, are keywords, and they may not be used as binding names. The full list of keywords and reserved words is rather long.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> break case catch class const continue debugger default
 delete do else enum export extends false finally for
 function if implements import interface in instanceof let
 new package private protected public return static super
 switch this throw true try typeof var void while with yield
</code></pre></div></div>
<p>Don‚Äôt worry about memorizing this list. When creating a binding produces an unexpected syntax error, see whether you‚Äôre trying to define a reserved word.</p>

<h1 id="chapter-3-functions">Chapter 3. Functions</h1>
<p>A function is just a regular binding where the <strong>value</strong> is a function.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const square = function(x) {
   return x * x;
};
console.log(square(4));
</code></pre></div></div>
<h2 id="scopes">Scopes</h2>
<ul>
  <li>A binding defined outside of a function or block is a <strong>global</strong> binding</li>
  <li>A binding created for function parameters or defined within a function is a <strong>local</strong> binding</li>
  <li>Bindings declared with <code class="highlighter-rouge">let</code> or <code class="highlighter-rouge">const</code> are local to the <strong>block</strong></li>
  <li>Each scope can <strong>look out</strong> to the scope around it, except where multiple bindings have the same name</li>
  <li>Multiple degress of locality exist when functions and blocks are created within other functions and blocks (i.e. nested)</li>
</ul>

<h2 id="declaration-notation">Declaration notation</h2>
<ul>
  <li>A shorter way of declaring a function, using <code class="highlighter-rouge">function</code> keyword at the start</li>
  <li>Almost the same, except that they are logically <strong>moved</strong> to the top of their scope</li>
</ul>

<h2 id="arrow-notation">Arrow notation</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const square1 = (x) =&gt; { return x * x; };
const square2 = x =&gt; x * x;
</code></pre></div></div>
<h2 id="parameters">Parameters</h2>
<ul>
  <li>If too many arguments are passed, extra ones are ignored</li>
  <li>If too few, the remaining are set to <code class="highlighter-rouge">undefined</code></li>
  <li>Using <code class="highlighter-rouge">=</code> gives a default value in the case it is not specified</li>
</ul>

<h2 id="closures">Closures</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function wrapValue(n) {
  let local = n;      // creates a local binding
  return () =&gt; local; // returns a function which accesses this
}
let wrap1 = wrapValue(1);
let wrap2 = wrapValue(2);
console.log(wrap1()); // ‚Üí 1
console.log(wrap2()); // ‚Üí 2
</code></pre></div></div>
<ul>
  <li>Local bindings are created anew for each call to <code class="highlighter-rouge">wrapValue</code></li>
  <li>Different calls are completely seperate</li>
  <li>This feature ‚Äî being able to reference a specific instance of a local binding in an enclosing scope ‚Äî is called <strong>closure</strong>.</li>
  <li>A function that references bindings from local scopes around it is called <strong>a closure</strong>.</li>
</ul>

<p>The <code class="highlighter-rouge">local</code> variable from <code class="highlighter-rouge">wrapValue</code> isn‚Äôt necessary since the parameter itself is a local variable. Therefore equivalent to:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function wrapValue(n) {
  return () =&gt; n;
}
</code></pre></div></div>
<p>Use this idea to create functions which multiply by an arbitrary amount:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function multiplier(factor) {
   return number =&gt; number * factor;
}
let twice = multiplier(2);
console.log(twice(5)); // ‚Üí 10
</code></pre></div></div>
<p>Thinking about programs like this takes some practice. A good mental model is to think of function values as containing both the code in their body and the environment in which they are created. When called, the function body sees the environment in which it was created, not the environment in which it is called.</p>

<h2 id="functions-and-side-effects">Functions and side-effects</h2>
<p>Functions can be roughly divided into those that are called for their side effects and those that are called for their return value. (Though it is definitely also possible to both have side effects and return a value.)<br />
A <strong>pure</strong> function is a specific kind of value-producing function that not only has no side effects but also doesn‚Äôt rely on side effects from other code</p>

<h1 id="chapter-4-objects-and-arrays">Chapter 4. Objects and Arrays</h1>
<h2 id="properties">Properties</h2>
<ul>
  <li>Almost all JavaScript values have properties (with the exception of null and undefined).</li>
  <li>Both <code class="highlighter-rouge">value.x</code> and <code class="highlighter-rouge">value[x]</code> access a property on value
    <ul>
      <li>Using a dot, the word after the dot is the literal name of the property.</li>
      <li>Using square brackets, the expression between the brackets is evaluated and converted to a string to get the property name</li>
    </ul>
  </li>
  <li>Properties with names which aren‚Äôt naturally strings (e.g. 2; ‚ÄúJohn Doe‚Äù) must use square bracket notation</li>
  <li>Elements in an array are stored as the array‚Äôs properties, using numbers as property names (and therefore must use square bracket notation)</li>
  <li>Properties that contain functions are generally called methods of the value they belong to, as in ‚ÄútoUpperCase is a method of a string‚Äù.</li>
</ul>

<h2 id="objects">Objects</h2>
<ul>
  <li>Values of the type object are arbitrary collections of properties</li>
  <li>One way to create an object is by using braces as an expression</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let day1 = {
squirrel: false,
events: ["work", "touched tree", "pizza", "running"]
};
</code></pre></div></div>
<ul>
  <li>Quote binding names if necessary</li>
  <li><code class="highlighter-rouge">Object.keys</code> returns an array of strings, the object‚Äôs property names</li>
  <li><code class="highlighter-rouge">Object.assign</code> copies all properties from one object into another</li>
</ul>

<h2 id="arrays">Arrays</h2>
<ul>
  <li>Arrays are simply a kind of object specialized for storing sequences of things</li>
  <li>Arrays have an <code class="highlighter-rouge">includes</code> method that checks whether a given value exists in the array</li>
  <li>Iterate over arrays and strings with <code class="highlighter-rouge">for ... of</code> e.g. <code class="highlighter-rouge">for (let entry of journal)</code></li>
  <li><code class="highlighter-rouge">slice</code> returns a sub section of an array</li>
  <li><code class="highlighter-rouge">concat</code>glues arrays together to create a new array (similar to <code class="highlighter-rouge">+</code> for strings)</li>
</ul>

<h2 id="strings">Strings</h2>
<ul>
  <li><code class="highlighter-rouge">indexOf</code> can search for more than one letter (unlike arrays)</li>
  <li><code class="highlighter-rouge">padStart</code></li>
  <li><code class="highlighter-rouge">split</code></li>
  <li><code class="highlighter-rouge">join</code></li>
</ul>

<h2 id="rest-parameters">Rest parameters</h2>
<ul>
  <li>To accept any number of arguments, add <code class="highlighter-rouge">...</code> before the last argument e.g. <code class="highlighter-rouge">function max(...numbers)</code> a.k.a. the <strong>rest parameter</strong></li>
  <li>The rest parameter is bound to an array</li>
  <li>Use <code class="highlighter-rouge">...</code> to <em>call</em> such a function with an array e.g. <code class="highlighter-rouge">let numbers = [5, 1, 7]; console.log(max(...numbers));</code> - ‚Äúspreading‚Äù out the array into the function call</li>
</ul>

<h2 id="destructuring">Destructuring</h2>
<ul>
  <li>When a function takes an array for a parameter, the function parameters can instead target individual items in the array e.g. <code class="highlighter-rouge">function phi([n00, n01, n10, n11])</code></li>
  <li>Works for <code class="highlighter-rouge">let</code>, <code class="highlighter-rouge">const</code> or <code class="highlighter-rouge">var</code> as well as parameters</li>
  <li>Works for objects too using <code class="highlighter-rouge">{}</code> e.g. <code class="highlighter-rouge">let {name} = {name: "Faraji", age: 23}; // "Faraji"</code></li>
</ul>

<h1 id="chapter-5-higher-order-functions">Chapter 5. Higher-Order Functions</h1>
<ul>
  <li>Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher-order functions (term is from mathematics where there is more difference between a ‚Äúfunction‚Äù and a ‚Äúvalue‚Äù)</li>
  <li>Allow abstracting over <em>actions</em> (not just <em>values</em>)</li>
  <li>Functions which create new functions:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function greaterThan(n) {
 return m =&gt; m &gt; n; // returns a **function**
}
let greaterThan10 = greaterThan(10);
console.log(greaterThan10(11));
// ‚Üí true
</code></pre></div>    </div>
  </li>
  <li>Functions which change other functions - e.g. log input and output as well as call an existing function</li>
  <li>Array have a variety of higher-order functions defined including:
    <ul>
      <li><code class="highlighter-rouge">forEach</code> to loop over the elements in an array</li>
      <li><code class="highlighter-rouge">filter</code> returns a new array of only elements passing the predicate function</li>
      <li><code class="highlighter-rouge">map</code> transform all elements in an array according to the given function</li>
      <li><code class="highlighter-rouge">reduce</code> combines all elements in an array into a single value</li>
      <li><code class="highlighter-rouge">some</code> tests whether any element in an array passes a given predicate function</li>
      <li><code class="highlighter-rouge">findIndex</code> finds the position of the first element passing a given predicate function</li>
    </ul>
  </li>
</ul>

<h1 id="chapter-6-the-secret-life-of-objects">Chapter 6. The Secret Life of Objects</h1>
:ET