I"Y<h2 id="merge-sort">Merge Sort</h2>

<p>Sort the left half, then sort the right half, then merge the two halves together. The left half can be sorted using the same algorithm. Recursively applying this will eventually lead to just one element that requires “sorting”, another element which requires “sorting” and then merging these two together. When they get merged they are merged into a new array. This is followed by the right half of that half, then unwind back up the stack, merging as we go until the entire array is sorted.
Running time is O(n log n).
Takes more memory due to having to hold and extra array which the halves are merged into.</p>

<h2 id="file-io">File IO</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FILE* f = fopen("filename", "r") // open the file in read only mode
</code></pre></div></div>

<p>where the last argument is one of “r”, “W”, “a” (a for append)
Always check for NULL after trying to open the file</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fputs("hello world", f); // writes the string to a file
fputs("\n", f);

fgets(output, sizeof(output), f); // reads a line from a file

// read a text file line by line
for (int i = 1; fgets(output, sizeof(output), f) != NULL; i++)
    printf("Line %02d: %s", i, output);
</code></pre></div></div>

<p>To check that the reason the NULL pointer is reached <em>is</em> due to the end of the file (and not some other error) it is possible to check either the <code class="highlighter-rouge">ferror</code> or <code class="highlighter-rouge">feof</code> functions.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (feof(f)) { ... }

fclose(f);  // close the file
</code></pre></div></div>

<h2 id="structs">Structs</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct
{
    int age;
    char *name;
};
</code></pre></div></div>

<p>Useful, but this doesn’t create anything e.g. like saying <code class="highlighter-rouge">int;</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct
{
    int age;
    char *name;
} student;
</code></pre></div></div>

<p>Now we have an anonymous struct and a variable <code class="highlighter-rouge">student</code> which has 2 attributes <code class="highlighter-rouge">name</code> and <code class="highlighter-rouge">age</code> which we can use via <code class="highlighter-rouge">.</code> e.g. <code class="highlighter-rouge">student.name = 12</code>.</p>

<p>In order to create multiple objects, we need to give the struct a name:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct student
{
    int age;
    char *name;
} s1;

struct student s1; // alternative way to declare a struct student
Struct student s2 = {1, "Fred"}; // concise initialisation, similar to arrays

s1 = s2; // assign s1 the same values as s2
s1.age = 10; // here s2 does not change (just as y does not change when you say x = y and then x = 4;)
</code></pre></div></div>

<p>Instead of writing <code class="highlighter-rouge">struct student</code> everywhere we could use a <code class="highlighter-rouge">typedef</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct
{
    int age;
    char *name;
} student;
</code></pre></div></div>

<p>Now we can use <code class="highlighter-rouge">student</code> everywhere that we used to use <code class="highlighter-rouge">struct student</code>. This typedef’s an anonymous struct and calls it student.</p>

<h3 id="structs-and-functions">Structs and Functions</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void func(student s) { ... }
func(s1);
</code></pre></div></div>

<p>The struct behaves exactly as an integer would if passed to a function. The function recieves a copy of s1 and so can’t modify s1. To actually pass in s1, you need to change the function definition to take a *student and pass s1 in by address:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void func(student *s) { ... }
func (&amp;s1);
</code></pre></div></div>

<p>Added benefit is that the fields in the struct don’t need to be passed into the stack frame now (even if we don’t want to modify s1).</p>

<h3 id="structs-and-pointers">Structs and Pointers</h3>

<p>Creating a pointer to a struct is also possible.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>student *s = malloc(sizeof(student));
</code></pre></div></div>

<p>BUT how do we now access the <code class="highlighter-rouge">age</code> member?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*s.age = 32;    // by default this puts the brackets around s.age as in *(s.age) = 32 so won't work
(*s).age = 32;  // correct, but annoying / confusing syntax
s-&gt;age = 32;    // nice syntax
</code></pre></div></div>

<h2 id="valgrind">Valgrind</h2>

<p>Helps to detect memory leaks. Runs on the executable of a program.</p>

:ET