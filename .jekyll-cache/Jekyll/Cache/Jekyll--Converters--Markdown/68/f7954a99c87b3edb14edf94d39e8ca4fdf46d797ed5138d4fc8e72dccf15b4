I"¸-<h3 id="references">References</h3>

<blockquote>
  <p>This book is dedicated to equality, which is significantly harder to achieve in the real world than overriding Equals()and GetHashCode().</p>
</blockquote>

<p>Book website: https://csharpindepth.com
Publishers website: https://www.manning.com/books/c-sharp-in-depth-fourth-edition</p>

<h1 id="part-1-c-in-context">Part 1: C# in context</h1>
<h2 id="chapter-1-survival-of-the-sharpest">Chapter 1: Survival of the sharpest</h2>
<h3 id="a-helpful-type-system">A helpful type system</h3>
<p>Statically typed languages help show intent in large programs.</p>
<ul>
  <li>Evolution includes: generics (C#2), nullable types (C#2), immutable structs (C#7), nullable reference types (C#8) i.e. any reference type not explicitly marked nullable, can‚Äôt be null</li>
  <li>Anonymous types and <code class="highlighter-rouge">var</code> (both C#3) reduced verbosity. Anonymous types are useful if you need a particular data shape within a method, but nowhere else, often used for LINQ. They only help within a single block of code however - they can‚Äôt be used in parameters OR return types.</li>
  <li>Tuples (C#7) and the ability to name elements means they could be used instead of anonymous types in some cases and CAN be used in params or return types</li>
  <li>Record types (C#8) are essentially named anonymous types
    <h3 id="concise-code">Concise code</h3>
    <p>C#‚Äôs features allow you to reduce <strong>ceremony</strong>, remove <strong>boilerplate</strong> code, and avoid <strong>cruft</strong>.</p>
  </li>
  <li>Method group conversions and anonymous methods (C#2) for writing delegates more concisely.</li>
  <li>Lamda expressions (C#3) for delegate with even shorter syntax</li>
  <li>Object and collection initialisers from LINQ where properties can be set inline during initialisation</li>
  <li>Automatically implemented properties (C#3, improved in later versions)</li>
  <li>Expression-bodied members (C#6) for when a method or property is a single expression, using <code class="highlighter-rouge">=&gt;</code> syntax: <code class="highlighter-rouge">member =&gt; expression</code></li>
  <li>Caller information attributes (C#5) for diagnostics and debugging where a method can receive information about the calling method, namely: the method name, the line number and the file path at compile time</li>
</ul>

<h3 id="data-access-with-linq">Data access with LINQ</h3>
<ul>
  <li>Query expressions - compile-time checking, intellisense, efficient database queries</li>
  <li>Expression trees for querying out of process data (e.g. SQL server)</li>
  <li>LINQ encourages thinking about data transformations in terms of functional programming
    <h3 id="asynchrony">Asynchrony</h3>
  </li>
  <li><code class="highlighter-rouge">async</code> and <code class="highlighter-rouge">await</code> (C#5) allowing the writing of asynchronous code, which looks similar to more familiar synchronous code</li>
</ul>

<h1 id="part-2--c-2-5">Part 2:  C# 2-5</h1>
<h2 id="chapter-2-c-2">Chapter 2: C# 2</h2>
<p>C# 2 was released with Visual Studio 2005 and .NET 2.0. Important features were generics, better constructs for writing both delegates and iterators.</p>
<h3 id="generics">Generics</h3>
<p>General purpose code which is type safe at compile time. Mainly used in collections, delegates (particularly LINQ), async code with <code class="highlighter-rouge">Task&lt;T&gt;</code> and nullable value types.</p>
<ul>
  <li><strong>Parameter</strong>: a method declares its inputs as <strong>parameters</strong></li>
  <li><strong>Argument</strong>: these are provided by the calling code in the form of <strong>arguments</strong></li>
</ul>

<p>Generics has <strong>type parameters</strong> and <strong>type arguments</strong>, same idea but applied to types.</p>

<ul>
  <li>Generic classes - generic type declared immediately after the name of the class in angle brackets e.g. <code class="highlighter-rouge">public class Car&lt;T&gt;</code>. Methods within the class can be expressed with parameters and return types in terms of <code class="highlighter-rouge">T</code>.</li>
  <li>Generic methods - a generic method declares type parameters immediately after the name of the method in angle brackets which can be used in other parts of the method signature, the parameters or return type e.g.</li>
  <li>Generic classes can implement generic interfaces by using the type declared by the class</li>
  <li>Classes and methods with the same name, but a different ‚Äúarity‚Äù of type parameters is ok e.g. <code class="highlighter-rouge">class Car&lt;T&gt;</code> and <code class="highlighter-rouge">class Car&lt;T1, T2&gt;</code></li>
  <li>Enums <strong>can‚Äôt</strong> be generic, but classes, structs, interfaces and delegates can be</li>
  <li>Methods <strong>can</strong> be generic, but fields, properties, indexers, constructors, events and finalizers can‚Äôt be</li>
  <li>If the type(s) of a generic method can be inferred from the type of the arguments (where the type is used in specifying the parameters) then you don‚Äôt need to specify the type when calling the method. If there are multiple type arguments, need to either specify none or all.</li>
  <li>Only methods allow type inference, so static factory methods can be useful to create types more easily e.g. see <code class="highlighter-rouge">Tuple</code> https://referencesource.microsoft.com/#mscorlib/system/tuple.cs,9124c4bea9ab0199 - then allows writing <code class="highlighter-rouge">Tuple.Create(10, "x", 20)</code> instead of <code class="highlighter-rouge">new Tuple&lt;int, string, int&gt;(10, "x", 20)</code></li>
  <li>If type inference fails, explicitly specify or cast arguments e.g. <code class="highlighter-rouge">Tuple.Create(10, (string)null, 50)</code></li>
  <li>Constrain generic type arguments to certain types using <code class="highlighter-rouge">where</code> e.g. to ensure elements of type <code class="highlighter-rouge">T</code> implement <code class="highlighter-rouge">IFormattable</code> declare the method: <code class="highlighter-rouge">void PrintItems&lt;T&gt;(List&lt;T&gt; items) where T : IFormattable</code>. This additionally allows any <code class="highlighter-rouge">IFormattable</code> methods to be called on this input.</li>
  <li><code class="highlighter-rouge">default()</code> is useful when dealing with generics in methods e.g. <code class="highlighter-rouge">T x = default(T);</code></li>
  <li>A type of <code class="highlighter-rouge">System.Collections.Generic.List`1[System.Int32]</code> means a generic type of <code class="highlighter-rouge">List</code> with arity 1 (one type parameter) and the type of that argument is <code class="highlighter-rouge">System.Int32</code></li>
  <li>the <code class="highlighter-rouge">typeof</code> operator ONLY can also take an argument e.g. <code class="highlighter-rouge">typeof(List&lt;&gt;)</code> and refers to the generic type definition itself. Add commas to indicate multiple arguments e.g. <code class="highlighter-rouge">typeof(Dictionary&lt;,&gt;)</code> or <code class="highlighter-rouge">typeof(Tuple&lt;,,,&gt;)</code></li>
</ul>

<h3 id="nullable-value-types">Nullable value types</h3>
<p>A nullable type encapsulates the value and a flag. At the core is the <code class="highlighter-rouge">public struct Nullable&lt;T&gt; : where T : struct</code> struct.</p>
<ul>
  <li>Can be used with primitive types, enums, system-provided structs and user-defined structs</li>
  <li>Type <code class="highlighter-rouge">T</code> is the ‚Äúunderlying type‚Äù of <code class="highlighter-rouge">Nullable&lt;T&gt;</code> (i.e. <code class="highlighter-rouge">int</code> is the underlying type of <code class="highlighter-rouge">Nullable&lt;int&gt;</code>)</li>
  <li>Boxing behaviour of value types and nullable value types is different. A nullable value type has no ‚Äúboxed‚Äù form - it is simply either null or the boxed form of the underlying value</li>
  <li>Strange note - calling GetType() on a value type variable requires it to be boxed first</li>
  <li>Using <code class="highlighter-rouge">?</code> is completely equivalent to using <code class="highlighter-rouge">Nullable&lt;T&gt;</code> e.g. <code class="highlighter-rouge">int?</code>, <code class="highlighter-rouge">Int32?</code></li>
  <li>When a nullable value type is <code class="highlighter-rouge">null</code>, the value is <code class="highlighter-rouge">null</code> and the <code class="highlighter-rouge">HasValue</code> property is false i.e. <code class="highlighter-rouge">int? x = new int?()</code> and <code class="highlighter-rouge">int? x = null</code> are equivalent (and <code class="highlighter-rouge">x.HasValue</code> will return false, NOT throw a null reference exception)</li>
  <li><code class="highlighter-rouge">as</code> could additionally be used with nullable value types in C#2 (check out pattern matching for C#7 onwards)</li>
  <li><code class="highlighter-rouge">??</code> can be used to assign to a value type IF one side is also a value type</li>
</ul>

<p>With regards to the fact that trying to access the value of a nullable value type which doesn‚Äôt have a value will throw an exception:</p>
<blockquote>
  <p>I think it‚Äôs important enough to restate: progress doesn‚Äôt come just from making it easier to write correct code; it also comes from making it harder to write broken code or making the consequences less severe.</p>
</blockquote>

<h3 id="simplified-delegate-creation">Simplified delegate creation</h3>
<blockquote>
  <p>The basic purpose of delegates is to encapsulate a piece of code so that it can be passed around and executed as necessary in a type-safe fashion in terms of the return type and parameters.</p>
</blockquote>

<ul>
  <li>A delegate is essentially a function contained in an object - allows you to specify a sequence of actions to be execute at a later time</li>
  <li>Four parts to delegates:
    <ul>
      <li>A <strong>delegate type</strong> needs to be declared e.g. <code class="highlighter-rouge">delegate void StringProcessor(string input)</code> - this delegate type can point to any method which takes one string parameter and doesn‚Äôt return anything</li>
      <li>The code to be executed must be contained in a method (either an existing one, or by writing a new one)</li>
      <li>A delegate instance must be created - exact form depends on whether method is instance or static</li>
      <li>The delegate instance must be invoked - a method <code class="highlighter-rouge">Invoke</code> is always present in the delegate with the same parameters and return type as delgate type declaration e.g. <code class="highlighter-rouge">delegateX.Invoke("hey")</code></li>
    </ul>
  </li>
  <li>Shorthand exists to omit the call to <code class="highlighter-rouge">Invoke</code> by treating the delegate variable as a method e.g. <code class="highlighter-rouge">delegateX("hey")</code></li>
  <li>Delegates tended to be used for event handling or starting threads in C#1 and also in C#2. LINQ in C#3 made delegates and passing functions around more commonplace</li>
  <li>Method group conversions simplify specifying a delegate instance from <code class="highlighter-rouge">var proc = new StringProcessor(PrintString)</code> to <code class="highlighter-rouge">StringProcessor proc = PrintString;</code></li>
  <li>Anonymous methods preceeded lamda expressions and allowed specifying a delegate instance without having to have a separate method e.g.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>StringProcessor proc = delegate(string input) { Console.Write($"{input}") }
</code></pre></div>    </div>
    <h3 id="iterators">Iterators</h3>
  </li>
</ul>
:ET