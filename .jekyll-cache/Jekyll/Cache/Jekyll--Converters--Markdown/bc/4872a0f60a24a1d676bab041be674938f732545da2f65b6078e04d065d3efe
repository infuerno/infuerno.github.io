I"	K<h1 id="introduction">Introduction</h1>
<p>Made up of various NuGet package libraries in the <code class="highlighter-rouge">Microsoft.EntityFrameworkCore.*</code> packages.</p>
<h2 id="versions">Versions</h2>
<ul>
  <li>EF Core 1.0 June 2016</li>
  <li>EF Core 2.0 August 2017 - lots of changes, first solid version</li>
  <li>EF Core 2.1 May 2018 (Minor update) - important update with lots of new features</li>
</ul>

<h2 id="orms">ORMs</h2>
<p>Typically, ORMs use the same structure in the classes and the database tables. EF has a mapping layer which gives more flexibility: objects -&gt; tables and object properties -&gt; table columns. <strong>Conventions</strong> are used as a starting point. <img src="https://www.dropbox.com/s/bjys3tm3i9zn1vb/Screenshot%202019-12-28%2012.05.53.png?raw=1" alt="" />
Still need to understand how EF Core works, nuances with tracking changes that need to be persisted to the database and patterns for working with disconnected applications.</p>
<h2 id="available-providers">Available Providers</h2>
<p>Include: SQL Server (Microsoft), SQLite (Microsoft, Devart), InMemory (Microsoft), SQL Server Compact, MySQL, Oracle, PostgreSQL, DB2, MyCat, Firebird.</p>

<h2 id="open-source">Open Source</h2>
<ul>
  <li>Available on GitHub under the <code class="highlighter-rouge">aspnet</code> account</li>
  <li>Tied to the release cycle of dotnet core</li>
  <li>EF Core 2.0 runs on .NET Standard 2.0 (supported by .NET Framework 4.6.1+)</li>
</ul>

<h2 id="how-ef-core-works">How EF Core Works</h2>
<ul>
  <li>Write the domain class - nothing to do with EF</li>
  <li>Define the data model based on those domain classes. Write LINQ to entities queries against those classes. Call save changes.</li>
  <li>EF tracks changes, builds and execute SQLs. Manages all the connectivity to the database.</li>
  <li>If there is an existing database, can use scaffolding to generate context and model. From this point on use migrations.</li>
  <li>Tables names are pluralalized by default when mapping from data model classes</li>
</ul>

<h2 id="workflow">Workflow</h2>
<ul>
  <li>Define domain classes</li>
  <li>Use EF to wrap these domain classes in a model, define how the model maps to the database schema</li>
  <li>Write LINQ to entities using the provider for the chosen database technology</li>
  <li>Can map to views instead of tables</li>
  <li>Can use SPs if query is too difficult to express with LINQ</li>
  <li>EF can keep track of changes as long as the context is in scope (e.g. desktop application). For disconnected apps there are patterns to inform EF of the state of an object when e.g. a web app returns with changes</li>
</ul>

<h2 id="ef-6-vs-ef-core-1-vs-ef-core-2">EF 6 vs EF Core 1 vs EF Core 2</h2>
<ul>
  <li>EF 6 (2013) moved to CodePlex and became open source. Now moved to GitHub (aspnet group)</li>
  <li>Some features will NEVER come to EF
    <ul>
      <li>No EDMX/Designer in EF Core (could use DevArt or LLBLGenPro)</li>
      <li>Database first still works (using the scaffold command), can also use EF Reverse POCO Code First Generator by Simon Hughes</li>
    </ul>
  </li>
  <li>Basic model remains the same
    <ul>
      <li>Define a data model with classes and a DbContext.</li>
      <li>DbContext and DbSets are still there</li>
      <li>Create and migrate databases as the model changes</li>
      <li>Query with LINQ to Entities</li>
      <li>EF tracks changes to entities in memory</li>
      <li>Will still add and attach entities to the context</li>
      <li>NEW Update method - automatically set the state to modified</li>
      <li>SaveChanges still exists to push changes back to the data store</li>
    </ul>
  </li>
  <li>New features
    <ul>
      <li>Batch insert, update and delete</li>
      <li>Specify Unique FKs in entities</li>
      <li>LINQ queries - allow providers to choose which part of queries are actioned in memory and which in SQL - can then use inline functions - compose LINQ on top of RAW SQL</li>
      <li>Better disconnected patterns</li>
      <li>InMemory provider for testing</li>
      <li>Mapping to backing fields (not just properties)</li>
      <li>Mapping to IEnumerables</li>
    </ul>
  </li>
  <li>Differences from EF6 to EF Core
    <ul>
      <li><code class="highlighter-rouge">Include</code> works differently in how it queries for related data</li>
      <li>Db entry method behaves differently - see August 2016 - Data Points - EF Core Change-Tracking Behaviour</li>
    </ul>
  </li>
  <li>Updates for EF Core 2
    <ul>
      <li>Querying
        <ul>
          <li>EF.Functions.Like()</li>
          <li>More LINQ run on the database</li>
          <li>Global filters per type</li>
          <li>Explicitly compile queries (already in EF 6)</li>
          <li><code class="highlighter-rouge">GroupJoin</code> generated SQL is better (already in EF 6)</li>
        </ul>
      </li>
      <li>Mapping
        <ul>
          <li>Map to UDF scalar functions in the database (already in EF 6)</li>
          <li>Owned Entities (replaces EF 6 complex type / value object support)</li>
          <li>Table splitting (already in EF 6)</li>
        </ul>
      </li>
      <li>Performance
        <ul>
          <li>DbContext pooling</li>
          <li>String interpolation in raw SQL</li>
          <li>Consolidate logging and diagnostics</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="creating-a-data-model-and-database-with-ef-core">Creating a Data Model and Database with EF Core</h1>
<ol>
  <li>Define domain models for <code class="highlighter-rouge">Sumurai</code>, <code class="highlighter-rouge">Battle</code> and <code class="highlighter-rouge">Quote</code>. NOTE that
    <ul>
      <li><code class="highlighter-rouge">Samurai</code> has a <code class="highlighter-rouge">List&lt;Quotes&gt;</code> and <code class="highlighter-rouge">Quote</code> has a <code class="highlighter-rouge">SamuraiId</code></li>
      <li>Similarly, <code class="highlighter-rouge">Battle</code> has a <code class="highlighter-rouge">List&lt;Samurai&gt;</code> and <code class="highlighter-rouge">Samurai</code> has a <code class="highlighter-rouge">BattleId</code></li>
      <li>Strangely, <code class="highlighter-rouge">Quote</code> ALSO has a reference to <code class="highlighter-rouge">Samurai</code> TOO</li>
    </ul>
  </li>
  <li>Add NuGet package for provider e.g. SqlServer to add in all other dependencies</li>
  <li>Add Context class and defined <code class="highlighter-rouge">DbSet</code>s. By adding a DbSet for each domain class, will be able to query all 3 directly.</li>
  <li>EF 6 had magic to infer the provider and the database string. in EF Core there is NO MORE MAGIC - must specify the provider and connection string. Need to explicitly set both.
    <ul>
      <li>Override the dbContext’s OnConfiguring method and use <code class="highlighter-rouge">optionsBuilder.UseSqlServer</code> to specify the connection string (database doesn’t need to exist)</li>
      <li>The first time the context is instantiated, the OnConfiguring method will be called. The Migrations API will also be able to benefit from this setting.</li>
    </ul>
  </li>
  <li>Every time the model changes, a new migration needs to be created.
    <ul>
      <li>Install the package <code class="highlighter-rouge">EntityFrameworkCore.Tools</code></li>
      <li>Set the start up project to a project which can execute. (if targeting .NET Standard can adjust <code class="highlighter-rouge">TargetFrameworks</code> in the Samurai.Data .csproj to <code class="highlighter-rouge">&lt;TargetFrameworks&gt;netcoreapp3.1;netstandard2.0&lt;/TargetFrameworks&gt;</code>)</li>
      <li><code class="highlighter-rouge">Get-Help EntityFrameworkCore</code> to show info on all the migration commands</li>
      <li><code class="highlighter-rouge">Add-Migration Initial</code> to add a new migration (ensure correct Data project picked in PMC dropdown)</li>
      <li>A Migrations folder is created, a file with the migration code AND a ModelSnapshot.cs is also created which reflects the current database schema - useful when working in teams - NEW TO EF CORE</li>
      <li>Can use <code class="highlighter-rouge">Script-Migration</code> to produce a script of migrations - recommended for production databases</li>
      <li>Database will be created automatically using <code class="highlighter-rouge">Update-Database</code>, but must be created beforehand when using <code class="highlighter-rouge">Script-Migration</code></li>
      <li>The <code class="highlighter-rouge">EFMigrations</code> table contains the Migration name. Previously used to contain the snapshot, which created headaches for teams using source control.</li>
    </ul>
  </li>
</ol>

<h2 id="use-di-container-to-provide-a-preconfigured-dbcontextoptions-to-set-up-the-dbcontext">Use DI container to provide a preconfigured DbContextOptions to set up the DbContext</h2>
<ul>
  <li>Remove <code class="highlighter-rouge">OnConfiguring</code> method and instead code a constructor which accepts a <code class="highlighter-rouge">DbContextOptions&lt;SamuraiContext&gt;</code> options object which is sent to the base constructor.  The web app, where the DI container is configured, now has to have access to EF and the provider. In Core 2.1 and before, the NuGet package <code class="highlighter-rouge">Microsoft.AspNet.All</code> provided all libraries required. In Core 3 it still just works, but need to add EFCore.Design additionally.</li>
</ul>

<h2 id="many-to-many-relations">Many to Many relations</h2>
<ul>
  <li>Requires a Join Entity to link them (maps to a Join Table)</li>
  <li>Create a class for the join e.g. <code class="highlighter-rouge">SamuraiBattle</code> with at least two properties for <code class="highlighter-rouge">SamuraiId</code> and <code class="highlighter-rouge">BattleId</code> (and optionally two navigation properties for <code class="highlighter-rouge">Samurai</code> and <code class="highlighter-rouge">Battle</code>)</li>
  <li>Need to specify the joint primary key in the <code class="highlighter-rouge">OnModelCreating</code> method</li>
</ul>

<h2 id="one-to-one-relations">One to One relations</h2>
<ul>
  <li>Add a <code class="highlighter-rouge">SecretIdentity</code> property to <code class="highlighter-rouge">Samurai</code>. This will be optional (default behaviour - need to use business logic if want to ensure exists)</li>
  <li>Add a <code class="highlighter-rouge">SamuraiId</code> to <code class="highlighter-rouge">SecretIdentity</code> (a <code class="highlighter-rouge">SecretIdentity</code> cannot be parentless)</li>
</ul>

<blockquote>
  <p>The dependent end of a 1 to 1 relationship is ALWAYS optional</p>
</blockquote>

<h1 id="interacting-with-ef-core-model">Interacting with EF Core Model</h1>
<h2 id="logging">Logging</h2>
<ul>
  <li>Logging will be added to the context class</li>
  <li>Install Microsoft.Extensions.Logging.Console</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static readonly LoggerFactory ConsoleLoggerFactory
 = new LoggerFactory(new[] {
   new ConsoleLoggerProvider((category, level)
    =&gt; category == DbLoggerCategory.Database.Command.Name
    &amp;&amp; level == LogLevel.Information, true)
});
</code></pre></div></div>
<ul>
  <li>Then in the options configuration, add the <code class="highlighter-rouge">.UseLoggerFactory()</code> method to configure with the logger created.</li>
</ul>

<h2 id="inserting">Inserting</h2>
<ul>
  <li>SaveChanges ALWAYS wraps all commands in a transaction - so if any fail, all will be rolled back</li>
  <li>Use <code class="highlighter-rouge">context.Add</code> to directly add entities. EF will work out which type of entity is being added. Also works well with <code class="highlighter-rouge">context.AddRange()</code> to add different types of entities.</li>
</ul>

<h2 id="querying">Querying</h2>
<ul>
  <li><code class="highlighter-rouge">context.Samarais.ToList()</code> to fetch all <code class="highlighter-rouge">Samurai</code>s. <code class="highlighter-rouge">ToList()</code> is a LINQ Execution method</li>
  <li>LINQ Query Syntax can also be used, but would still need to use an execution method at the end e.g. <code class="highlighter-rouge">from s in context.Samurais select s).ToList()</code></li>
  <li>The query itself is disconnected from the method which EXECUTES the query</li>
  <li>Alternative to using an execution method is to ENUMERATE the query e.g. using a foreach loop and writing out some information. However a connection is opened at the beginning of the enumeration and stays open until the last result is fetched. This can cause issues if e.g. processing each item is intensive. Advisable to get all entries and THEN process.</li>
  <li>When you use the same context for multiple operations, it will keep track of all operations.</li>
</ul>

<h3 id="linq-to-entities-execution-methods">LINQ to Entities Execution Methods</h3>
<p>|Method|Async Method|Notes|
|—|—|—|
|ToList()|ToListAsync()|
|First()|FirstAsync()|
|FirstOrDefault()|FirstOrDefaultAsync()|
|Single()|SingleAsync()|
|SingleOrDefault()|SingleOrDefaultAsync()|
|Last()|LastAsync()|Require query to have an <code class="highlighter-rouge">OrderBy</code> method
|LastOrDefault()|LastOrDefaultAsync()|Require query to have an <code class="highlighter-rouge">OrderBy</code> method
|Count()|CountAsync()|
|LongCount()|LongCountAsync()|
|Min()|MinAsync()|
|Max()|MaxAsync()|
|Average()|AverageAsync()|
|Find(key)|FindAsync(key)|Not a LINQ method, but a DbSet method which will execute. If object is already in memory (i.e. being tracked by the context) it won’t hit the db, but return that object|</p>

<p>All apart from <code class="highlighter-rouge">ToList()</code> all perform some kind of aggregation, the logic of which executes on the database</p>

<h2 id="simple-updates">Simple updates</h2>
<p>For connected apps, the entity can be retrieved, updated and the changes saved using the same context. The context is therefore aware of exactly what has changed and can optimised the SQL accordingly by ONLY updating generating update statements for the attributes it knows has changed.</p>

<h2 id="disconnected-updates">Disconnected updates</h2>
<p>For web applications where an entity is retrieved by one context (and sent to a client browser) and then updated using a different context, EF is NOT tracking this updated entity and therefore has no idea what has changed. In this scenario, the <code class="highlighter-rouge">context.Update()</code> method needs to be called (EF will start tracking the entity and then set the state to modified). The SQL which is generated has updates for ALL attributes.</p>
<h3 id="tools-for-tracking-between-server-and-client">Tools for tracking between Server and Client</h3>
<ul>
  <li>Breeze - Rich data for JS apps <a href="https://getbreezenow.com">https://getbreezenow.com</a></li>
  <li>Trackable Entities - N-Tier support for EF <a href="https://trackableentities.github.io">https://trackableentities.github.io</a></li>
</ul>

<h2 id="deletions">Deletions</h2>
<p>These work in a similar way using the <code class="highlighter-rouge">.Remove()</code> set of methods on either the DbSet OR the context itself. The SQL generated simply deletes the object using the ID. However it is NOT possible to call remove using the ID. Either call remove using the whole object OR use <code class="highlighter-rouge">Find(key)</code> followed by <code class="highlighter-rouge">Remove()</code></p>

<h2 id="executing-raw-sql">Executing Raw SQL</h2>
<p>See previous course for further information.</p>
<ul>
  <li>Use <code class="highlighter-rouge">context.Database.ExecuteSqlCommand("exec DeleteById {0}", samuraiId)</code></li>
  <li>OR use <code class="highlighter-rouge">DbSet.FromSql()</code> method which replaces <code class="highlighter-rouge">DbSet.SqlQuery</code> and <code class="highlighter-rouge">DbSet.Database.SqlQuery()</code></li>
</ul>

<h1 id="working-with-related-data">Working with Related Data</h1>
<h2 id="inserting-related-data">Inserting related data</h2>
<p>When EF is tracking the parent, it will automatically be tracking the child too. Simply add / update a child and issue SaveChanges for the children to be added / updated. e.g. retrieve samurai, add quote, save changes.</p>

<p>When disconnected and EF is not tracking the parent object, in order to add the child without first retrieving the parent, use the FK SamuraiId property of the child. Best to AVOID the graph when the objects have different states.</p>

<p>This means having FK properties in child classes BUT they make life MUCH EASIER.</p>
<h2 id="loading-related-data">Loading related data</h2>
<ol>
  <li>Eager loading</li>
  <li>Projections</li>
  <li>Explicit loading</li>
  <li>Lazy loading (only supported in EF Core 3 +)</li>
</ol>

<h3 id="eager-loading">Eager Loading</h3>
<ul>
  <li>Use <code class="highlighter-rouge">Include()</code></li>
  <li>Ensure it is used BEFORE any query execution method</li>
  <li>For children AND grandchildren use <code class="highlighter-rouge">Include</code> and <code class="highlighter-rouge">ThenInclude()</code></li>
  <li>To only load grandchildren use <code class="highlighter-rouge">Include</code> directly specifying the grandchildren e.g. <code class="highlighter-rouge">samurais.Include(s =&gt; s.Quotes.Translations)</code></li>
  <li><code class="highlighter-rouge">Include</code> does not allow you to specify WHICH related data is returned, will simply load ALL children for the parents specified</li>
</ul>

<h3 id="projections">Projections</h3>
<ul>
  <li>Usually use <code class="highlighter-rouge">Select</code> to specify which properties to return, e.g. using an anonymous type e.g. <code class="highlighter-rouge">samurais.Select(s =&gt; new { s.Id, s.Name }).ToList()</code></li>
  <li>NOTE can only use the anonymous type in the same method. To return to a different method, use an actual type (e.g. IdAndName struct) OR cast to dynamic e.g. <code class="highlighter-rouge">listOfAnonTypes.ToList&lt;dynamic&gt;()</code></li>
  <li>To include related data add this to the projection e.g. <code class="highlighter-rouge">samurais.Select(s =&gt; new { s.Id, s.Name, s.Quotes }).ToList()</code></li>
  <li>Can filter the related data in this method e.g. <code class="highlighter-rouge">samurais.Select(s =&gt; new { s.Id, s.Name, s.Quotes.Where(q =&gt; q.Text.Contains("happy")) }).ToList()</code></li>
  <li>BROKEN. Should then be able to get samurais AND their quotes using a filter e.g. <code class="highlighter-rouge">samurais.Select(s =&gt; new { Samurai = s, Quotes = s.Quotes.Where(q =&gt; q.Text.Contains("happy")) }).ToList()</code></li>
  <li>WORKING. By simply executing multiple selects on the SAME context, EF will correctly join up the object graph</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>context.Samurais.ToList();
context.Quotes.Where( ...).ToList();
</code></pre></div></div>

<p>THERE IS A LOT MORE TO PROJECTIONS .. (but this is only a Getting Started course)</p>
:ET