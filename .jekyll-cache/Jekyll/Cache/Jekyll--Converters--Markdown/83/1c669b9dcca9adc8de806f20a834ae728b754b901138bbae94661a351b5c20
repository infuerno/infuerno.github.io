I"'F<h2 id="1-getting-started">1 Getting Started</h2>
<h3 id="about-version-control">About Version Control</h3>

<ul>
  <li>Local VCS e.g. copy files, RCS (patch sets = differences between files) - no good for collaboration; single point of failure</li>
  <li>Centralized VCS e.g. CVS, Subversion, Perforce - single server with all files, client checkout files - needs central server to be available, also single point of failure</li>
  <li>Distributed VCS e.g. Git, Mercurial - complete copy of repo on each client, collaberate with different people in different ways</li>
</ul>

<h3 id="a-short-history-of-git">A Short History of Git</h3>

<p>Developed in 2005 by the Linux kernel team after the propriatary DVCS tool they were using (BitKeeper) revoked the free-of-charge status. As per the original design goal, it is fast, efficient with large projects and has a strong branching system</p>

<h3 id="git-basics">Git Basics</h3>

<p>Git stores and thinks about information in a very different way to other version control systems, so it is important to understand the main concepts.</p>

<ul>
  <li>Snapshots, Not Differences. Most systems store data as a list of file based changes i.e. a set of files and the changes made to those files over time aka delta-based version control. Git instead thinks of its data as a stream of snapshots. When you commit, Git takes a snapshot of your files. If the file hasn’t changed a link to the previous file is stored instead. This fundamental difference means nearly every aspect of version control has been reconsidered. More in Git Branching.</li>
  <li>Nearly Every Operation Is Local. Much faster. Very little you can’t do locally</li>
  <li>Git Has Integrity. Git checksums everything using SHA-1 hash which means nothing can get corrupted or changed without Git knowing about it</li>
  <li>Git Generally Only Adds Data. After commiting a snapshot into Git it is very difficult to lose.</li>
  <li>The Three States. V IMPORTANT. There are three main states a file can be in: committed, modified and staged. Can it be both staged and modified when a file has been staged, but further changes have been made? These correspond to the 3 sections of a Git project: the <code class="highlighter-rouge">.git</code> directory, the working tree and the staging area. The <code class="highlighter-rouge">.git</code> directory contains the metadata and object data for the repo. The working tree is a single checkout out of one version, pulled from the <code class="highlighter-rouge">.git</code> directory. The staging area or index is a file (usually within <code class="highlighter-rouge">.git</code>) containing details of the next commit.</li>
</ul>

<h3 id="first-time-git-setup">First-Time Git Setup</h3>

<ul>
  <li>Using the <code class="highlighter-rouge">git config</code> tool</li>
  <li>Stores configs in one of 3 places:
    <ul>
      <li>system wide in <code class="highlighter-rouge">/etc/gitconfig</code> - using the <code class="highlighter-rouge">--system</code> flag</li>
      <li>per user in <code class="highlighter-rouge">~/.gitconfig</code> or <code class="highlighter-rouge">~/.config/git/config</code> using the <code class="highlighter-rouge">--global</code> flag</li>
      <li>per repo in <code class="highlighter-rouge">.git/config</code> default OR using the <code class="highlighter-rouge">--local</code> flag to be explicit</li>
    </ul>
  </li>
  <li>Windows locations are completely different</li>
  <li>Always set <code class="highlighter-rouge">user.name</code> and <code class="highlighter-rouge">user.email</code> after installation (can always override on project by project basis if nec)</li>
  <li><code class="highlighter-rouge">core.editor</code> to use a different editor to the system default</li>
  <li><code class="highlighter-rouge">core.autocrlf input|true|false</code> to control how line endings are treated</li>
  <li><code class="highlighter-rouge">git config --list</code> to show all settings (contextual to the git repo if appropriate). Settings may appear more than once, last one is used</li>
  <li><code class="highlighter-rouge">git config user.name</code> to query the value of a particular setting - use with <code class="highlighter-rouge">--show-origin</code> to show where configured</li>
</ul>

<h3 id="getting-help">Getting Help</h3>

<ul>
  <li><code class="highlighter-rouge">git help &lt;verb&gt;</code> OR <code class="highlighter-rouge">man git-&lt;verb&gt;</code> to bring up the various man pages e.g. <code class="highlighter-rouge">man git</code>, <code class="highlighter-rouge">man git-branch</code></li>
</ul>

<blockquote>
  <p>git - the stupid content tracker
We divide Git into high level (“porcelain”) commands and low level (“plumbing”) commands.</p>
</blockquote>

<h2 id="2-git-basics">2 Git Basics</h2>

<h3 id="adding-files-staging-modified-files">Adding Files, Staging Modified Files</h3>

<p><code class="highlighter-rouge">git add</code> is a multipurpose command</p>

<ul>
  <li>begin tracking new files</li>
  <li>stage files</li>
  <li>mark merge-conflicted files as resolved</li>
</ul>

<p>If a file is modified after running <code class="highlighter-rouge">git add</code>, it needs to be run again to stage the latest version of the file.</p>

<h3 id="short-status">Short Status</h3>

<p><code class="highlighter-rouge">git status --short</code> (<code class="highlighter-rouge">git status -s</code>) short status showing two columns of statuses, first one for staging area, second one for working tree</p>

<h3 id="ignoring-files">Ignoring Files</h3>

<p>Rules for the patterns in the <code class="highlighter-rouge">.gitignore</code>:</p>

<ul>
  <li>Blank lines or lines starting with # are ignored</li>
  <li>Standard glob patterns work, and will be applied recursively throughout the entire working tree</li>
  <li>Starting patterns with a forward slash (/) to avoid recursivity</li>
  <li>Ending patterns with a forward slash (/) to specify a directory</li>
  <li>Negate patterns by starting it with an exclamation point (!)</li>
</ul>

<p>Comprehensive list of .gitignore file examples for different projects and languages at https://github.com/github/gitignore. Multiple <code class="highlighter-rouge">.gitignore</code> files are also possible. <code class="highlighter-rouge">.gitignore</code> files in subdirectories only apply to that directory</p>

<h3 id="viewing-changes">Viewing Changes</h3>

<ul>
  <li><code class="highlighter-rouge">git diff --staged</code> ( or <code class="highlighter-rouge">git diff --cached</code>) to diff staged files. If a file has modifications since being staged, the two different edits can be seen using <code class="highlighter-rouge">git diff</code> and <code class="highlighter-rouge">git diff -staged</code>.</li>
  <li><code class="highlighter-rouge">git difftool</code> to view diffs in external software e.g. emerge, vimdiff etc</li>
  <li><code class="highlighter-rouge">git difftool --tool-help</code> for locally available tools</li>
</ul>

<h3 id="committing-changes">Committing Changes</h3>

<ul>
  <li><code class="highlighter-rouge">git commit</code> by itself will launch the editor, with the files to be commited in a comment. Any comment lines are stripped out of the commit message.</li>
  <li><code class="highlighter-rouge">git commit -v</code> will additionally show the diff (again will be stripped out of the actual commit message)</li>
</ul>

<h3 id="skipping-the-staging-area">Skipping the Staging Area</h3>

<p>Skip <code class="highlighter-rouge">git add</code> by using <code class="highlighter-rouge">git commit -a</code> - will commit every file with changes already being tracked. USE WITH CAUTION.</p>

<h3 id="removing-files">Removing Files</h3>

<ul>
  <li><code class="highlighter-rouge">git rm</code> to mark a file for removal. Will be deleted from the working tree on commit. If the file already has staged changes, the <code class="highlighter-rouge">-f</code> flag must be used to remove it (since the changes staged will be lost since not part of any commit snapshot).</li>
  <li><code class="highlighter-rouge">git rm --cached</code> to unstage a file</li>
  <li>Files, directories and file-glob patterns can all be used</li>
</ul>

<h3 id="viewing-the-commit-history">Viewing the Commit History</h3>

<ul>
  <li><code class="highlighter-rouge">git log</code> shows commit info in descending order</li>
  <li><code class="highlighter-rouge">git log -p</code> shows each patch</li>
  <li><code class="highlighter-rouge">git log --stat</code> with stats</li>
  <li><code class="highlighter-rouge">git log -pretty=online</code> or various other</li>
  <li><code class="highlighter-rouge">git log -pretty=format:"%h %ae %s</code> with various options available for format</li>
  <li><code class="highlighter-rouge">git log --graph</code> to show an ASCII branch and merge history e.g. <code class="highlighter-rouge">git log --pretty=format:"%h %s" --graph</code></li>
  <li><code class="highlighter-rouge">git log --since=2.weeks</code></li>
  <li><code class="highlighter-rouge">git log --author [email]</code></li>
  <li><code class="highlighter-rouge">git log --grep bug</code></li>
  <li><code class="highlighter-rouge">git log --all-match -grep bug --author [email]</code> default behaviour is to match any of the matches, add <code class="highlighter-rouge">all-match</code> to match all</li>
  <li>Pickaxe: <code class="highlighter-rouge">git log -p -2 -S showInputMenu</code> to show commits (including diff) which contained “showInputMenu” somewhere in the diff</li>
  <li><code class="highlighter-rouge">git log --no-merges</code> don’t show merge commits (may be useful depending on workflow used)</li>
</ul>

<h3 id="undoing-things">Undoing Things</h3>

<ul>
  <li><code class="highlighter-rouge">git commit --amend</code> redo your last commit - if nothing else staged just the message, otherwise if additional files have been staged, these will be added</li>
  <li>Can also unstage files and undo pending changes - HOWEVER be aware that any changes not committed will be completely lost. Usually better to stash or branch.</li>
</ul>

<h3 id="working-with-remotes">Working with Remotes</h3>

<p>The url of a remote is assigned an alias. For example <code class="highlighter-rouge">origin</code> is used when initially using <code class="highlighter-rouge">git clone</code>. Add a remote manually using <code class="highlighter-rouge">git remote add &lt;alias&gt; &lt;url&gt;</code> Use <code class="highlighter-rouge">git fetch</code> to pull down all the information from the remote repo to your local machine. Branches from the remote repo are now accessible locally at <code class="highlighter-rouge">&lt;alias&gt;/&lt;branchname&gt;</code> e.g. <code class="highlighter-rouge">origin/master</code>. This can be be merged into an existing branch in the local repo OR a local copy checked out.</p>

<p>If a local branch is set to track a remote branch (automatically done when using <code class="highlighter-rouge">git clone</code>) then <code class="highlighter-rouge">git pull</code> can be used to do a <code class="highlighter-rouge">git fetch</code> followed by a <code class="highlighter-rouge">git merge</code>.</p>

<p><code class="highlighter-rouge">git remote show origin</code> to show information about a remote repo, remote branches and any tracking in place with local branches</p>

<h3 id="tagging">Tagging</h3>

<ul>
  <li><code class="highlighter-rouge">git tag</code> to list tags or <code class="highlighter-rouge">git tag -l "v1.8.5*"</code> for all tags matching a certain pattern</li>
  <li>Lightweight tag - pointer to a specific commit</li>
  <li>Annotated tags - recommended - stored as full objects: checksummed with tagger name, email, date and message and can be signed e.g. <code class="highlighter-rouge">git tag -a v1.4 -m "my version 1.4"</code> (as with commit, omitting the <code class="highlighter-rouge">-m</code> will launch the default editor). Use <code class="highlighter-rouge">git show</code> to see the tag data e.g. <code class="highlighter-rouge">git show v1.4</code></li>
  <li>Tag a specific commit using the short hash e.g. <code class="highlighter-rouge">git tag -a v1.2 9fceb02</code></li>
  <li>Tags are shared with remotes automatically, but need to be pushed</li>
</ul>

<h4 id="checking-out-tags">Checking out Tags</h4>

<p>To see the contents of the files a tag is pointing to, the tag needs to be checked out e.g. <code class="highlighter-rouge">git checkout v1.4</code>. NOTE: this puts the repository in “detached HEAD” state. In this state, commits can be made, but won’t be attached to any branch, so will be unreachable (except via the commit hash). If a branch is required use: <code class="highlighter-rouge">git checkout -b version2 v2.0.0</code>.</p>

<h3 id="git-aliases">Git Aliases</h3>

<p>Create aliases for git commands via config:</p>

<ul>
  <li><code class="highlighter-rouge">git config --global alias.co checkout</code> to then use <code class="highlighter-rouge">git co -b new-branch</code></li>
  <li><code class="highlighter-rouge">git config --global alias.unstage 'reset HEAD --'</code> to more easily unstage a file <code class="highlighter-rouge">git unstage file.txt</code></li>
  <li><code class="highlighter-rouge">git config --global alias.last 'log -1 HEAD'</code> to easily see the last commit</li>
</ul>

<p>Use <code class="highlighter-rouge">!</code> for commands which aren’t git subcommands:</p>

<ul>
  <li><code class="highlighter-rouge">git config --global alias.visual '!gitk'</code> to then use <code class="highlighter-rouge">gitk</code> instead of <code class="highlighter-rouge">git visual</code></li>
</ul>

<h2 id="3-git-branching">3 Git Branching</h2>

<p>Git branching is fast and git encourages workflows which branch and merge often. Understanding git branching requires understanding how git stores data. Git stores data as a series of snapshopts.</p>

<h3 id="branches-in-a-nutshell">Branches in a Nutshell</h3>

<p>A commit object contains:</p>

<ul>
  <li>the author’s name and email</li>
  <li>the commit message</li>
  <li>a pointer to the snapshot which was staged</li>
  <li>pointers to the previous commit (or commits when it is the result of the merge between multiple branches)</li>
</ul>

<p>Stage: checksum each file, store that file version in the Git repository (blob)
Commit: checksum each subdirectory, store tree objects, create commit object</p>

<p>A branch is simply a (movable) pointer to a commit object.</p>

<p>HEAD is a special pointer which points to the current branch. <code class="highlighter-rouge">git log --decorate</code> shows where the branch pointers are currently pointing (info also included in <code class="highlighter-rouge">git log --oneline</code>)</p>

<p>Checking out a different branch changes where the HEAD is pointing to AS WELL AS updating files in the working directory. IF this cannot be done cleanly (e.g. because there are unstaged changes) Git will not let you switch.</p>

<p>Useful log command to see branch info: <code class="highlighter-rouge">git log --oneline --decorate --graph --all</code></p>

<h3 id="basic-branching-and-merging">Basic Branching and Merging</h3>

<p>Switching between branching is straightforwards if you have a clean working area. If the working directory or staging area has uncommitted changes, stashing and commit amending may be required (more later).</p>

<p>Merge hotfix branches back into master using <code class="highlighter-rouge">git checkout master &amp;&amp; git merge hotfix</code>. If there is no divergent history Git will just fast-foward master (i.e. move the branch pointer forwards). Having merged back, delete brances no long required: <code class="highlighter-rouge">git branch -d hotfix</code>. NOTE master may also need to be merged into other branches now.</p>

<p>When there is divergent history, Git does a three-way merge using the snapshots of both tips and the snapshot of the common ancestor of the two branches. This involves creating a new snapshot and is called <em>merge commit</em>. This new snapshot has more than one parent. If Git can’t merge this automatically the merge results in conflicts which need to be resolved. Edit each file and “stage” them to mark them resolved.</p>

<p><code class="highlighter-rouge">git mergetool</code> to resolve conflicts in the visual merge tool configured.</p>

<h3 id="branch-management">Branch Management</h3>

<ul>
  <li><code class="highlighter-rouge">git branch -v</code> to see the list of branches as well as the last commit on each branch</li>
  <li><code class="highlighter-rouge">git branch --merged</code> for all branches which have been merged into the current working branch (and therefore safe to delete)</li>
  <li><code class="highlighter-rouge">git branch --no-merged</code> for any branches still to be merged (trying to delete such a branch will give a warning)</li>
  <li>Specify a branch name last for another branch</li>
</ul>

<h3 id="branching-workflows">Branching Workflows</h3>

<h4 id="long-running-branches">Long-Running Branches</h4>

<p>3 branches:</p>

<ul>
  <li><code class="highlighter-rouge">master</code> - stable code (has or will be released)</li>
  <li><code class="highlighter-rouge">develop</code> or <code class="highlighter-rouge">next</code> - work from this branch or use to test stability</li>
  <li><code class="highlighter-rouge">pu</code> or <code class="highlighter-rouge">proposed</code> - proposed update branch - for integrated work not yet ready to go into <code class="highlighter-rouge">next</code></li>
  <li><code class="highlighter-rouge">topic</code> - single short-lived branch for a particular feature</li>
</ul>

<p>Work is merged into the branch above when it is more stable. This workflow is often helpful when dealing with large or complex projects.</p>
:ET