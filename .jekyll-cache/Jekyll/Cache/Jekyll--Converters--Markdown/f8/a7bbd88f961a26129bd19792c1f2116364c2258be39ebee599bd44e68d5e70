I"R1<p>Reference: <a href="http://openmymind.net/redis.pdf">http://openmymind.net/redis.pdf</a></p>

<h2 id="databases">Databases</h2>

<p>Databases are simply identified by a number. The default is 0. Change to another database using <code class="highlighter-rouge">select 1</code>.</p>

<h2 id="data-structures">Data structures</h2>

<ul>
  <li>Redis has 5 data structures: string (scalar), hashset, list, set, sorted set</li>
  <li>Each of these has at least a key and a value</li>
  <li>Organise keys using <code class="highlighter-rouge">:</code> e.g. a typical key would be <code class="highlighter-rouge">users:leto</code></li>
  <li>Values can be anything: strings, numbers, json, xml etc (redis stores as a byte array and doesn’t care)</li>
  <li>Objects cannot by retrieved by their value. This requires the data to be modelled in a certain way and can limit the usefulness of Redis.</li>
</ul>

<h3 id="string-scalar">String (scalar)</h3>

<ul>
  <li>Simple key value pairs</li>
  <li>As always, the values can be anything (not just strings)</li>
</ul>

<p>Useful for:</p>

<ul>
  <li>Storing instances of objects by key e.g. with the object represented by JSON</li>
  <li>Counters</li>
  <li>Caching data (since key look up is so fast)</li>
</ul>

<p>Common operations include:</p>

<ul>
  <li><code class="highlighter-rouge">set &lt;key&gt; &lt;value&gt;</code> to set a value e.g. <code class="highlighter-rouge">set users:leto '{"name": "leto", "planet": "dune", "likes": ["spice"]}'</code></li>
  <li><code class="highlighter-rouge">get &lt;key&gt;</code> to get a value e.g. <code class="highlighter-rouge">get users:leto</code></li>
  <li><code class="highlighter-rouge">strlen &lt;key&gt;</code> to retrieve a value’s length’</li>
  <li><code class="highlighter-rouge">getrange &lt;key&gt; &lt;start&gt; &lt;end&gt;</code> to get a substring of the value</li>
  <li><code class="highlighter-rouge">append &lt;key&gt; &lt;value&gt;</code> to append to an existing value (or create if not already exists)</li>
  <li><code class="highlighter-rouge">incr &lt;key&gt;</code> and <code class="highlighter-rouge">decr &lt;key&gt;</code> to increment / decrement an existing integer value</li>
  <li><code class="highlighter-rouge">incrby &lt;key&gt; &lt;step&gt;</code> and <code class="highlighter-rouge">decrby &lt;key&gt; &lt;step&gt;</code> to increment / decrement by a specified amount</li>
  <li><code class="highlighter-rouge">setbit</code> and <code class="highlighter-rouge">getbit</code> to perform bitwise operations on values</li>
</ul>

<h3 id="hashes">Hashes</h3>

<ul>
  <li>Similar to strings, but provide an extra level of indirection: a field</li>
</ul>

<p>Useful for:</p>

<ul>
  <li>Better control storing objects in terms of being able to get and set individual fields</li>
  <li>More flexibility in querying data</li>
</ul>

<p>Common operations:</p>

<ul>
  <li><code class="highlighter-rouge">hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</code> e.g. <code class="highlighter-rouge">hset users:goku powerlevel 9000</code></li>
  <li><code class="highlighter-rouge">hget &lt;key&gt; &lt;field&gt;</code> e.g. <code class="highlighter-rouge">hget users:goku powerlevel</code></li>
  <li><code class="highlighter-rouge">hmset &lt;key&gt; [&lt;field&gt; &lt;value&gt;]</code> to set multiple fields at once e.g. <code class="highlighter-rouge">hmset users:goku race saiyan age 737</code></li>
  <li><code class="highlighter-rouge">hmget &lt;key&gt; [&lt;field&gt;]</code> to get multiple fields at once e.g. <code class="highlighter-rouge">hmget users:goku race powerlevel</code></li>
  <li><code class="highlighter-rouge">hgetall &lt;key&gt;</code> to list all fields and values</li>
  <li><code class="highlighter-rouge">hkeys &lt;key&gt;</code> to list all fields</li>
  <li><code class="highlighter-rouge">hdel &lt;key&gt; &lt;field&gt;</code> to delete a specific field</li>
</ul>

<h3 id="lists">Lists</h3>

<ul>
  <li>Store and manipulate an array of values for a given key</li>
</ul>

<p>Useful for:</p>

<ul>
  <li>Storing keys to other objects which have a certain attribute in common e.g. a list of <code class="highlighter-rouge">newusers</code></li>
  <li>Storing other list type data structures e.g. logs, the path a user takes through a site, queued user actions in a game</li>
</ul>

<p>Common operations:</p>

<ul>
  <li><code class="highlighter-rouge">lpush &lt;list&gt; &lt;value&gt;</code> to push a user onto the front of a list</li>
  <li><code class="highlighter-rouge">ltrim &lt;list&gt; &lt;start&gt; &lt;end&gt;</code> to trim a list</li>
  <li><code class="highlighter-rouge">lrange &lt;list&gt; &lt;start&gt; &lt;end&gt;</code></li>
</ul>

<h3 id="sets">Sets</h3>

<ul>
  <li>Store a set of unique values</li>
  <li>Provide efficient value based operations</li>
</ul>

<p>Useful for:</p>

<ul>
  <li>Tagging or tracking properties of a value for which duplicates don’t make sense</li>
  <li>Storing items of e.g. friends where operations will include unions and intersections on values</li>
</ul>

<p>Common operations:</p>

<ul>
  <li><code class="highlighter-rouge">sadd &lt;key&gt; [&lt;value&gt;]</code></li>
  <li><code class="highlighter-rouge">sismember &lt;key&gt; &lt;value&gt;</code> in O(1) time</li>
  <li><code class="highlighter-rouge">sinter &lt;key1&gt; &lt;key2&gt;</code> to given the intersection of values</li>
  <li><code class="highlighter-rouge">sinterstore &lt;key_to_store&gt; &lt;key1&gt; &lt;key2&gt;</code> to store the intersections of values in a new key</li>
</ul>

<h3 id="sorted-sets">Sorted sets</h3>

<ul>
  <li>Like sets but with a score</li>
  <li>The score provides sorting and ranking capability</li>
</ul>

<p>Common operations:</p>
<ul>
  <li><code class="highlighter-rouge">zadd &lt;key&gt; [&lt;value&gt; &lt;score&gt;]</code> to add items to a sorted set in O(log(N)) time (where N is the number of items already in the set)</li>
  <li><code class="highlighter-rouge">zcount &lt;key&gt; &lt;start_score&gt; &lt;end_score&gt;</code> to return the count of values with scores in a certain range</li>
  <li><code class="highlighter-rouge">zrank &lt;key&gt; &lt;value&gt;</code> and <code class="highlighter-rouge">zrevrank &lt;key&gt; &lt;value&gt;</code> to get a value’s rank within a sorted set</li>
</ul>

<h2 id="memory-and-persistence">Memory and persistence</h2>

<p>Redis runs in memory and periodically persists to disk. By default Redis saves the whole database every 60 seconds if 1000 or more keys have changed up to 15 minutes if less than 9 keys have changed.</p>

<p>In addition to snapshotting Redis can run in append mode whereby an append-only file is updated every time a key changes.</p>

<h2 id="leveraging-data-sturctures">Leveraging data sturctures</h2>

<h3 id="lookup-by-value">Lookup by value</h3>

<p>By default redis only allows lookups by key. In order to perform queries using values, an seperate structure needs to be defined which makes these values in one object, keys in another. Hashs are perfect these indexes.</p>

<p><code class="highlighter-rouge">set users:9001 '{"id": 9001, "email": "leto@dune.gov", ...}'</code>
<code class="highlighter-rouge">hset users:lookup:email leto@dune.gov 9001</code></p>

<p><code class="highlighter-rouge">get users:9001</code> to look up someone by key
<code class="highlighter-rouge">hget users:leto@dune.gov</code> to get someone’s key by email and then use this to lookup via key</p>

<p>Remember, such indexes need to be created / managed / updated / deleted manually.</p>

<h3 id="maintaining-references-and-indexes">Maintaining references and indexes</h3>

<p><code class="highlighter-rouge">sadd friends:leto ghanima paul chani jessica</code></p>

<p>In the set above, the values are likely also keys to the details of that person. If chani changes her name, or deletes her account there is no easy way to work out which sets we need to update in order to ensure the reference set is still consistent. Using a numeric id would be preferable for the set. But this doesn’t resolve managing account deletions. Here a reverse index would need to also be maintained.</p>

<p><code class="highlighter-rouge">sadd friends_of:chani leto paul</code></p>

<h3 id="round-trips-and-pipelining">Round trips and pipelining</h3>

<p>Making round trips to the database are a common pattern in Redis. There are certain features in Redis which can be leveraged to get the most out of this pattern.</p>
<ul>
  <li><code class="highlighter-rouge">mget</code> takes multiple keys and returns values</li>
  <li><code class="highlighter-rouge">sadd</code> can add one or members to a set</li>
  <li>Pipelining allows sending multiple requests at the same time in a batch. In Ruby use the <code class="highlighter-rouge">redis.pipelined</code> block.</li>
</ul>

<h3 id="transactions">Transactions</h3>

<ul>
  <li>Every redis command is atomic.</li>
  <li>Groups sets of commands into one atomic transaction using the <code class="highlighter-rouge">multi</code> and then <code class="highlighter-rouge">exec</code> (or <code class="highlighter-rouge">discard</code>) keywords.</li>
</ul>

<p><strong>* BOTTOM OF PAGE 18 - DON’T UNDERSTAND</strong>*</p>

<h3 id="keys-anti-pattern">Keys anti-pattern</h3>

<p>The <code class="highlighter-rouge">keys &lt;pattern&gt;</code> command usefully takes a pattern and returns all matching keys. However, it does this by scanning through all existing keys and is therefore very slow. Avoid using this in production code and instead use a hash etc to provide an index for data retrieval on specific criteria.</p>

<h2 id="beyond-the-data-structures">Beyond the data structures</h2>

<h3 id="expiration">Expiration</h3>

<ul>
  <li><code class="highlighter-rouge">expire &lt;key&gt;</code> makes a key for expiration (useful in caching scenarios)</li>
  <li><code class="highlighter-rouge">ttl &lt;key&gt;</code> returns the ttl</li>
  <li><code class="highlighter-rouge">persist &lt;key&gt;</code> removes any ttl</li>
  <li><code class="highlighter-rouge">setex &lt;key&gt; &lt;ttl&gt; &lt;value&gt;</code> allows setting a value and expiration time in one command</li>
</ul>

<h3 id="pub-and-sub">Pub and sub</h3>

<ul>
  <li>
    <p>A simple queue can be powered using a list and the <code class="highlighter-rouge">blpop</code> and <code class="highlighter-rouge">brpop</code> commands which remove the first / last elements respectively or block until one is available.</p>
  </li>
  <li><code class="highlighter-rouge">subscribe [&lt;channel&gt;]</code> to subscribe to a channel(s)</li>
  <li><code class="highlighter-rouge">publish &lt;channel&gt; &lt;message&gt;</code> to send a message to a specific channel, will return the number of clients that received the message</li>
  <li><code class="highlighter-rouge">psubscribe &lt;pattern&gt;</code> to subscribe to channels based on a pattern</li>
  <li><code class="highlighter-rouge">unsubscribe</code> and <code class="highlighter-rouge">punsubscribe</code> to unsubscribe</li>
</ul>

<h3 id="monitor-and-slow-log">Monitor and slow log</h3>

<ul>
  <li><code class="highlighter-rouge">monitor</code> at the command prompt will begin showing all commands being exected against the redis database</li>
  <li><code class="highlighter-rouge">config set slowlog-log-slower-than 5</code> will log details of all commands which take longer than 5 microseconds to run</li>
  <li><code class="highlighter-rouge">slowlog get &lt;count&gt;</code> gets the history of slow commands (optional tail count)</li>
</ul>

<h3 id="sort">Sort</h3>

<ul>
  <li>Allows you to sort the values within a list, set or sorted set (sorted sets are only sorted by score)</li>
  <li><code class="highlighter-rouge">sort &lt;key&gt;</code> returns the values in ascending order</li>
  <li><code class="highlighter-rouge">sort limit &lt;offset&gt; &lt;count&gt; desc alpha</code> for paged results starting at page <code class="highlighter-rouge">&lt;offset&gt;</code> of <code class="highlighter-rouge">&lt;count&gt;</code> pages in descending order sorted lexicographically rather than numerically</li>
  <li>Also allows sorting on a referenced object either by strings or by hashes using a pattern which is substituted for the actual sort value in order to look up the key and hence the actual value to sort by</li>
  <li><code class="highlighter-rouge">sadd watch:leto 12339 1382 338</code>, <code class="highlighter-rouge">set severity:12339 3</code>, <code class="highlighter-rouge">set severity:1382 2</code>, <code class="highlighter-rouge">set severity:338 5</code></li>
</ul>

:ET