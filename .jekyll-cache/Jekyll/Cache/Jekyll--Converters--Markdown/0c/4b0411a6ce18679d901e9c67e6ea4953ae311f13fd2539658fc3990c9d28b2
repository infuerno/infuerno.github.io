I"©i<h2 id="context">Context</h2>
<h3 id="modern-c">Modern C++</h3>

<p>The standard library contains:</p>
<ul>
  <li>String class</li>
  <li>Collections (linked list, stack, queue etc)</li>
  <li>Smart pointers which handle memory management for you</li>
</ul>

<p>Managing memory yourself is <em>old-school</em>.</p>

<h3 id="ccli">C++/CLI</h3>

<p>C++/CLI is a variant of C++ which makes managed code. 
Visual Studio can compile C++ code either into native code or managed code. Managed code can be easily called from other .NET modules.
Note, choose CLR project to compile to managed code, choose Win32 projects to compile to native code.</p>

<h3 id="versions-of-c">Versions of C++</h3>

<p>C++ doesn‚Äôt belong to anybody. A standards committee decides on updates. First version was C++98 with a small update C++03. Next version was C++11 with a small update C++14.</p>

<h2 id="tools">Tools</h2>
<h3 id="visual-studio">Visual Studio</h3>

<p>Running a console application <em>without debugging</em> automatically give you a ‚ÄòPress any key to continue‚Ä¶‚Äô at the end so you can see all the output before closing the command window.</p>

<p>When creating a new project, click ‚Äúinclude pre-compiled header‚Äù to include the ‚Äústdafx.h‚Äù header file to make the application compile faster (not run faster).</p>

<h3 id="console-application-structure">Console Application Structure</h3>

<p><code class="highlighter-rouge">#</code> preprocessor directives
The preprocessor goes through the code before the compiler and tweaks it a little bit. One thing it does is combines multiple files into one. Put just the definitions of functionality into a header file and then include that header file into each file that needs it.
Includes from the Standard Library do not have the .h on the end.</p>

<p><code class="highlighter-rouge">::</code> scope resolution operator as in <code class="highlighter-rouge">std::cout</code></p>

<h2 id="language-basics">Language Basics</h2>

<p>C++ is strongly typed - once a variable is declared as an int, it is always an int.</p>

<p>Fundamental types are built into the language and include int, bool, char.
User defined types include e.g. std::string. They can do everything that fundamental types can do i.e. full participants in the language.</p>

<p>You can see there are red wigglies here. They say: Error: a value of type ‚Äúconst char *‚Äù cannot be used to initialize an entity of type ‚Äúchar‚Äù. The important part of that is probably the word ‚ÄòError‚Äô.</p>

<p>Fundamental Types on MSDN: <a href="http://msdn.microsoft.com/en-us/library/cc953fe1.aspx">http://msdn.microsoft.com/en-us/library/cc953fe1.aspx</a>
Data Type Ranges on MSDN: <a href="http://msdn.microsoft.com/en-us/library/s3f49ktz.aspx">http://msdn.microsoft.com/en-us/library/s3f49ktz.aspx</a></p>

<p>Different types hold different kinds of data with different lengths and different maxiumum values. When assigning doubles to ints, ints to bools, ints to chars etc, there are no runtime errors. However, the compiler knows the different lengths and will help you and issue warnings.</p>

<h3 id="casting">Casting</h3>

<p>Compiler will convert types when they‚Äôre compatible, with a warning if data might be lost. Error only if they are not compatible.
By casting, the compiler warnings disappear, though this still may lead to trouble. Safer casts available with templates.
Suffixes can be used to show the type of a literal and are a form of casting.</p>

<h3 id="overflow">Overflow</h3>

<p>Overflow can happen silently. E.g. char x = 300 will just assign the value 44 to x without error.</p>

<h2 id="user-defined-types">User defined types</h2>

<h3 id="classes-and-objects">Classes and objects</h3>

<ul>
  <li>When defining a class, don‚Äôt forget the trailing semi-colon, causes some weird error message on the line after the class declaration.</li>
  <li>Private and public sections (default is private) rather than declaring public or private for each thing.</li>
  <li>Access member variables and functions with <code class="highlighter-rouge">.</code></li>
  <li>Access static members and functions with <code class="highlighter-rouge">::</code></li>
  <li>To create a class, create two files, .cpp to contain the class and .h to contain the defintion</li>
  <li>Declare the variables and method signatures in the header file and include this in any other file you need to use it (including the .cpp class file).</li>
  <li>Memory is allocated but not initialised when declaring and object.</li>
  <li>
    <p>Constructors have special initialisation syntax to immediately assign values to the member variables</p>

    <p>Person::Person(string f, string l, int a) : fullname(f), lastname(l), age(a)
  {  <br />
      cout ¬´¬†‚ÄúConstructing‚Äù ¬´¬†firstname ¬´¬†‚Äù ‚Äú ¬´¬†lastname ¬´¬†endl;  <br />
  }</p>

    <p>Person p1(‚ÄúJames‚Äù, ‚ÄúSmith‚Äù, 23);  // created on the stack</p>

    <p>Person::~Person()
  {
      cout ¬´¬†‚ÄúDestructing‚Äù ¬´¬†firstname ¬´¬†‚Äù ‚Äú ¬´¬†lastname ¬´¬†endl;  <br />
  }</p>
  </li>
  <li>Every class has a default constructor if none others have been defined</li>
  <li>Objects created as above are created on the stack and automatically cleaned up when the object goes out of scope. If a destructor has been defined, this is automatically called at this point.</li>
  <li>With inheritance constructor of the base class is called first, then the derived class. With destructors it is in reverse.</li>
  <li>Only use <code class="highlighter-rouge">using namespace &lt;e.g. std&gt;</code> inside the .cpp files and not in the header files</li>
</ul>

<h3 id="enums">Enums</h3>

<p>Enums in c++ are not prefixed by the name of the enumeration, so have to be unique across all enumerations defined.
Generally just have a header file with the enum defined within.</p>

<h3 id="preprocessor">Preprocessor</h3>

<p>The preprocessor is most often used to include all files required into one file. This is achieved with preprocessor directives such as <code class="highlighter-rouge">#include "Person.h"</code>. If files are included multiple times, the compiler errors. Rather than keep track of the whole tree of inclusions, just use the <code class="highlighter-rouge">#ifndef</code> and <code class="highlighter-rouge">#endif</code> to defined a constant in your header file, which has the effect of thereafter only including that file if the constant hasn‚Äôt been defined.</p>

<p><code class="highlighter-rouge">#pragma once</code> does the same thing for Visual Studio.</p>

<h2 id="flow-of-control">Flow of control</h2>

<p>Now a momentary word about bracing style. People have arguments about brace positioning that far exceed the arguments they can have about politics or religion or any other major touch points.</p>

<h3 id="switch">Switch</h3>

<p><code class="highlighter-rouge">expression</code>s and <code class="highlighter-rouge">value</code>s must be integral type or enum</p>

<h3 id="functions">Functions</h3>
<ul>
  <li>Can take parameters by value or reference.</li>
  <li>Can return by value or reference (careful not to create a ‚Äòdangling‚Äô reference).</li>
  <li>Passing by reference is used when you want to change something OR when it is expensive to pass by reference even though the variable won‚Äôt be changed (use the <code class="highlighter-rouge">const</code> keyword here).</li>
  <li>Dangling reference is created when you return a reference to a variable created within the function. Once the function returns, the variable goes out of scope. The memory contents may remain the same for a while, so the code will seem to work, but at any moment can be overwritten. Compiler will try and warn of this.</li>
  <li>Must have a return type. If none, then keyword <code class="highlighter-rouge">void</code> is used. Sometimes see this used for paramters when there are no parameters, but not necessary.</li>
</ul>

<h4 id="free-functions">Free functions</h4>

<ul>
  <li>Declare before used in a header file, which can then be included in multiple places.</li>
  <li>Functions which aren‚Äôt part of a class are called global or <em>free</em> functions.</li>
</ul>

<h4 id="member-functions">Member functions</h4>

<ul>
  <li>Often don‚Äôt take parameters, but work instead on values in the class</li>
  <li>Often don‚Äôt return values, but store instead the value in the class</li>
</ul>

<h4 id="inline-functions">Inline functions</h4>

<ul>
  <li>Inline functions can be explicitly defined by putting the implemetation in the header file. (Actually the compiler may also decide to make other functions inline.)</li>
</ul>

<h4 id="error-messages">Error messages</h4>

<p>Errors from calling functions tend to come from one of two places:</p>
<ol>
  <li>the compiler - have you declared the function (usually in the .h)</li>
  <li>the linker - have you implemented the function (usually in the .cpp)</li>
</ol>

<p>For visual studio, the .cpp files in particular MUST be part of the project, not just exist in the folder.</p>

<h3 id="immediate-if">Immediate if</h3>
<p>Much cleaner to use immediate if if applicable: <code class="highlighter-rouge">result = something? 7: 302;</code></p>

<h2 id="operators">Operators</h2>

<p>0 matches false, everything else matches true.
Yoda syntax: <code class="highlighter-rouge">if (3==i)</code> (this is popular because if typo occurs and only one equals sign is entered, in this case there would be a compiler error).</p>

<h3 id="bitwise-operators">Bitwise operators</h3>

<p>These do the operations bit by bit, <code class="highlighter-rouge">&amp;</code> and <code class="highlighter-rouge">^</code>.
Commonly used to save space and time by packing individual bit values into a single number. E.g. if you have an operation which can take 7 different flags, one way is to take 7 different parameters, all alternatively, take a integer, check the lowest 7 bits of that integer to see if the options are on or off. This is implemented using constants (so you don‚Äôt have to work out which int corresponds to a certain set of options being on). flag1 = 1, flag2 = 2, flag3 = 4, flag4 = 8 etc. Bitwise or them to get your set of options, bitwise and them to check if the option is set or not.</p>

<h3 id="bitshift-operators">Bitshift operators</h3>

<p>Shifts all the bits along
e.g. 4¬†¬ª 1 is 2, 4 ¬´¬†1 is 8</p>

<h2 id="operator-overloading">Operator overloading</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int i = j + 3;
Order newOrder = oldOrder + newItem;
</code></pre></div></div>

<ul>
  <li>Usually a member function, sometimes a free function (e.g. if you didn‚Äôt have access to the Order class to change it, of if the first item was e.g. an int)</li>
</ul>

<p>Examples</p>
<ul>
  <li><code class="highlighter-rouge">firstname + " " + lastname</code> works becuase the <code class="highlighter-rouge">+</code> has been overloaded by the person who wrote the string class</li>
  <li><code class="highlighter-rouge">cout &lt;&lt; "hello"</code> works because the bitwise operator <code class="highlighter-rouge">&lt;&lt;</code> has been overloaded</li>
  <li>In collections and iterators, <code class="highlighter-rouge">++</code> is often overloaded to move onto the next</li>
</ul>

<h3 id="writing-an-overload">Writing an overload</h3>
<p>There are two ways of writing an overload:</p>
<ol>
  <li>
    <p>As a member function of whatever type is before the operator which takes one parameter, the type after the operator. Often, especially with comparison operators, the two types will be the same.</p>

    <p>// myObject &lt; something
 bool MyClass::operator&lt;(OtherType something)</p>
  </li>
  <li>
    <p>As a free function which takes two parameters. Often if this is a complement to a set of comparison operators on a class which defines comparison to e.g. int, these free function definitions will be included in the class .cpp file.</p>

    <p>// myObject &lt; something
 bool operator&lt;(MyClass myObject, OtherType something)</p>
  </li>
</ol>

<p>Since this isn‚Äôt a member of MyClass, it only has access to public member functions (unless you use <code class="highlighter-rouge">friend</code>). You can use friend by specifying that the free function is a <code class="highlighter-rouge">friend</code> inside the class definition. Thereafter the free function can access private member variables. This is one of the few situations where using <code class="highlighter-rouge">friend</code> is acceptable.</p>

<h2 id="templates">Templates</h2>

<ul>
  <li>Templates is the way C++ implements genericity. Unlike other languages, templates are resolved at compile time, not runtime.</li>
  <li>Write a class or a function and use it with a variety of types. e.g. typesafe collections</li>
  <li>Often rely on overload functions and can therefore work with both fundamental types and user defined types</li>
  <li>Much of the Standard Library is template based (formerly STL, or Standard Template Library)</li>
  <li>Both function and class templates tends to be implemented all at once in the include file rather than seperate header and .cpp file</li>
  <li>Author of some code which uses templates must ensure that types are compatible with templates chosen (and implement any extra functions required if necessary)</li>
  <li>Note, mostly people <em>use</em> templates rather than writing them</li>
</ul>

<h3 id="function-templates">Function templates</h3>

<p>The example below works for all types which have defined the less than operator. Note, for those that haven‚Äôt, the error messages are vague since they will often refer to the implentation and that isn‚Äôt obvious for the user of a function.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template &lt;class T&gt;
T max(T&amp; t1, T&amp; t2)
{
    return t1 &lt; t2? t2: t1;
}
</code></pre></div></div>

<ul>
  <li>The compiler can usually work out which type to use depending on the type of the operands, but you can specify it if necessary e.g. <code class="highlighter-rouge">max&lt;double&gt;(1.2, 3)</code> instead of <code class="highlighter-rouge">max(1.2, 3)</code></li>
</ul>

<h3 id="class-templates">Class templates</h3>

<p>An example of a template class which could take e.g. <code class="highlighter-rouge">int</code> or <code class="highlighter-rouge">float</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template &lt;class T&gt;
class Accum
{
private:
    T total;
public:
    Accum(T start): total(start) {};
    T operator+=(const  T&amp; T) {return total = total + t;};
    T GetTotal() {return total;}
};
</code></pre></div></div>

<ul>
  <li>
    <p>When instantiating template class, the type must be explicitly stated</p>

    <p>Accum<int> integers(0);
  integers += 7;</int></p>
  </li>
  <li>
    <p>Trying to add a string to the integers object will give a compile time exception (which is what we want with templates)</p>
  </li>
</ul>

<h3 id="template-specialization">Template specialization</h3>

<p>Compilers will generate appropriate code from the template for any type you pass it, but you can also specify the code you want if necessary. You may need this if:</p>

<ul>
  <li>Operator or function is missing</li>
  <li>
    <p>Operator of function used by the template has been written in such a way that is not appropriate for this case</p>
  </li>
  <li>First choice if e.g. operator function is missing - then just add that operator function as a free function (assumption is that you don‚Äôt have access to change the class code, or that don‚Äôt want to add in the operator function, maybe doesn‚Äôt fit)‚Ä¶ but someone may have already written it</li>
  <li>Second choice is template specialization (which was often required with c style strings, though less so now). However since templates are such a time saver, if you find one which is good, but not quite right, you‚Äôll need to know how to adapt it.</li>
</ul>

<p>Example of trying to accumulate Person (which doesn‚Äôt define operator+)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template &lt;&gt;
class Accum&lt;Person&gt;
    {
private:
    int total;
public:
    Accum(Person start): total(start) {};
    int operator+=(Person&amp; t) {return total = total + t.GetNumber();};
    int GetTotal() {return total;}
};
</code></pre></div></div>

<ol>
  <li>Take a copy of the template code</li>
  <li>Remove the <code class="highlighter-rouge">class T</code> from the template declaration on the first line</li>
  <li>Add the type fo the class declaration on the second line</li>
  <li>Replace type T with appropriate types (often the class type, but not necessarily)</li>
</ol>

<h2 id="pointers-and-references">Pointers and references</h2>

<h3 id="pointers">Pointers</h3>

<ul>
  <li>A pointer is a variable which holds the address of another variable</li>
  <li>They should either be initialised to an address or ‚Äònull‚Äô, but never just declared</li>
  <li>You can use the pointer to go through it get to the value it is pointing to (or indeed change the pointer to point to something else)</li>
  <li>
    <p>One way to get one is to take the address of an existing variable.</p>

    <p>int <em>pA = &amp;A; // note, either int *pA or int</em> pA works fine, importantly the type is <code class="highlighter-rouge">int *</code>
  pA = &amp;B; // now points to address of int variable B
  <em>pA = 5; // change the contents of the memory to 5, B now equals 5
  (</em>pA*)++; // increment the contents of the memory, new value is 6</p>
  </li>
  <li>When an <code class="highlighter-rouge">&amp;</code> is before a variable it means ‚Äúplease take the address of the instance of this variable‚Äù. (When the <code class="highlighter-rouge">&amp;</code> is at the end of a type, as e.g. in previous section above, it means an e.g. Person reference)</li>
  <li>
    <p>To get through the pointer to its target use the <code class="highlighter-rouge">*</code> operator</p>

    <p>*pA = 5</p>
  </li>
  <li>If the contents of the memory location is an object, you would need to access the members of the object via the <code class="highlighter-rouge">.</code> operator which would become <code class="highlighter-rouge">(*pO).SomeMember</code> or alternatively <code class="highlighter-rouge">p0-&gt;SomeMember</code></li>
  <li><code class="highlighter-rouge">-&gt;</code> is pronounced <em>points to</em> or <em>arrow</em></li>
  <li>Since pointers are not always initialised to be pointing to something, they can be initialised to ‚Äúnot pointing to anything‚Äù and should be. Choices are <code class="highlighter-rouge">0</code>, <code class="highlighter-rouge">NULL</code> (which has been defined in an application to point to 0) or <code class="highlighter-rouge">nullptr</code> (C++11)</li>
</ul>

<h3 id="references">References</h3>

<p>C++ got pointers from C, but added references. References are much simpler than pointers, and are like aliases. Unlike pointers, they can‚Äôt be changed to point to different places, the target is set on declaration and that‚Äôs that. Also don‚Äôt have to use different punction (<code class="highlighter-rouge">-&gt;</code>) to talk to the target, just use <code class="highlighter-rouge">.</code> as normal.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int&amp; rA = a; // set reference equal to a (hence alias analogy)
rA = b; // now aliasing b 
rA = 5; // change value to 5
</code></pre></div></div>

<h3 id="examples-of-bad-programming">Examples of bad programming</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int *badPointer; // declare a pointer, but not pointing to any memory
*badPointer = 3; // try to dereference the pointer, program blows up

int *badPointer = nullptr;
if (badPointer) // this will now resolve to true or false (would still error if try to deref)
{
    *badPointer = 3;
}

int &amp;badReference; // won't compile, has to point to something
</code></pre></div></div>

<h3 id="const">Const</h3>

<ul>
  <li><code class="highlighter-rouge">const</code> is a commitment to the compiler that you won‚Äôt change it</li>
  <li>Used when declaring a local variable <code class="highlighter-rouge">const int zero = 0</code></li>
  <li>As a function parameter
    <ul>
      <li><code class="highlighter-rouge">int foo(const int i)</code> - function won‚Äôt change the value of i</li>
      <li><code class="highlighter-rouge">int something(const Person&amp; p)</code> - less expensive to pass, if any code in function tries to change, compiler error. This in turn means that any functions which <code class="highlighter-rouge">something</code> calls on the Person&amp; must also be const functions which state that the values won‚Äôt change e.g. a GetName() method. They need to be declared as such <code class="highlighter-rouge">int GetName() const;</code> in both the header and .cpp file.</li>
    </ul>
  </li>
  <li><em>Const correctness</em> is the term used to get all this inline (can end up following a long thread if left to the end)</li>
</ul>

<h3 id="const-and-pointers">Const and pointers</h3>

<ul>
  <li><code class="highlighter-rouge">const</code> can also be used with pointers and has two possible meanings:
    <ul>
      <li>the pointer is constant and can‚Äôt chagne it to point to anything else e.g. <code class="highlighter-rouge">int * const cpI;</code></li>
      <li>or it is pointing to something const e.g. <code class="highlighter-rouge">const int *cpI;</code> in this case you can‚Äôt change the value of the target.</li>
      <li>can use both of course: <code class="highlighter-rouge">const int * const cpI;</code></li>
    </ul>
  </li>
</ul>

<h3 id="the-free-store">The Free Store</h3>

<ul>
  <li>Often called the heap, since this is how it is implemented, it is used to store longer lived variables.</li>
  <li>Create with <code class="highlighter-rouge">new</code></li>
  <li>Tear down with <code class="highlighter-rouge">delete</code></li>
</ul>

<h3 id="manual-memory-management">Manual memory management</h3>
<ul>
  <li>Manual memory management is hard with variety of mistakes e.g. delete too soon, delete twice, never delete</li>
  <li>Rule of three
    <ul>
      <li>Copy constructor</li>
      <li>Copy assignment operator</li>
      <li>Destructor</li>
    </ul>
  </li>
</ul>

<blockquote>
  <blockquote>
    <blockquote>
      <p>GREAT DEMO OF HOW TO IMPLEMENT WITH MANUAL MEMORY MANAGEMENT¬´&lt;</p>
    </blockquote>
  </blockquote>
</blockquote>

<h3 id="smart-pointers">Smart pointers</h3>

<ul>
  <li>C++11 has a nice range of smart pointers, which do all the manual memory management for you</li>
  <li>They are solid objects which contain a pointer</li>
  <li>When a smart pointer goes out of scope, the destructor calls the delete for you</li>
  <li>Imagine a template class with just one member variable, a pointer. The constructor saves the T* in a member variable, the destructor will delete the T*</li>
  <li>Copying is handled either by prevention OR by keeping a count of the references</li>
  <li><code class="highlighter-rouge">*</code> and <code class="highlighter-rouge">-&gt;</code> are overloaded</li>
  <li>All used exactly the same as traditional raw pointers</li>
</ul>

<h3 id="smart-pointers-in-the-standard-library">Smart pointers in the Standard Library</h3>

<ul>
  <li><code class="highlighter-rouge">shared_ptr</code> - reference counted behaves well in collections</li>
  <li><code class="highlighter-rouge">weak_ptr</code> - allows you to ‚Äúpeek‚Äù at shared_ptr without bumping the reference count</li>
  <li><code class="highlighter-rouge">unique_ptr</code> - non copyable</li>
</ul>

<h2 id="pointers-and-inheritance">Pointers and inheritance</h2>

<ul>
  <li>Inheritance in C++ uses pointers</li>
  <li>A pointer to a derived class can be stored as a pointer to a base class instead - if a function takes a pointer to e.g. a BankAccount and you pass it a SavingsAccount that works ok</li>
  <li>When a derived class overrides a function in the base class either implementation could run when the function name is called, depending on if the programmer has marked the function as <code class="highlighter-rouge">virtual</code> or not (default is not)</li>
  <li>Virtual functions are implemented through a virtual table, so a little more time and memory are used</li>
  <li>Smart pointers work in exactly the same way as raw pointers in inheritance situations</li>
  <li>The <code class="highlighter-rouge">virtual</code> keyword only needs to be added to the header file of the base class</li>
  <li>Careful that if there any methods which are virtual then also ensure to make sure that the destructor is virtual too</li>
</ul>

<h3 id="slicing">Slicing</h3>

<p>Slicing occurs when you pass objects by value and you pass e.g. a SavingsAccount when a function or object is expecting a BankAccount. The memory allocated is only enough for the BankAccount so anything extra in SavingsAccount is lost OR the copy will fail.</p>

<p>To avoid slicing always use references or pointers.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tweeter localT("Local", "Tweeter", 123, "@local")
Person localP = localT; // slicing occurs, twitter handle gets lost
cout &lt;&lt; localP.GetName() &lt;&lt; endl; // calls the Person version of the GetName() function

// fix with pointers (make Person and pointer, to the address of localT and dereference to call GetName())
Tweeter localT("Local", "Tweeter", 123, "@local")
Person *localP = &amp;localT; // slicing occurs, twitter handle gets lost
cout &lt;&lt; localP-&gt;GetName() &lt;&lt; endl; // calls the Person version of the GetName() function

// fix with references (just declare localP as Person&amp;)
Tweeter localT("Local", "Tweeter", 123, "@local")
Person&amp; localP = localT; // slicing occurs, twitter handle gets lost
cout &lt;&lt; localP.GetName() &lt;&lt; endl; // calls the Person version of the GetName() function
</code></pre></div></div>

<h3 id="cast-operators">Cast operators</h3>

<ul>
  <li><code class="highlighter-rouge">(type)</code> is one way, C style, but dangerous</li>
  <li><code class="highlighter-rouge">static_cast&lt;type&gt;</code> uses a template and resolves at compile time and may give a warning (or error) but up to you to ensure it‚Äôs safe</li>
  <li><code class="highlighter-rouge">dynamic_cast&lt;type&gt;</code> is much better
    <ul>
      <li>works with pointers to classes with virtual tables</li>
      <li>Uses a dynamic check at run time on the virtual table</li>
      <li>will give a null back if it fails which you can check for</li>
      <li>Note, casting e.g. a reference will fail</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">const_cast</code>, <code class="highlighter-rouge">reinterpret_cast</code> etc are dangerous</li>
</ul>

:ET