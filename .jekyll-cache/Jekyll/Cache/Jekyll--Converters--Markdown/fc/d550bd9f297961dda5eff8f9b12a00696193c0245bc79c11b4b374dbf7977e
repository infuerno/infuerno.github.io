I"n7<h2 id="quick-reference">Quick Reference</h2>

<ul>
  <li><code class="highlighter-rouge">docker images</code> - list images</li>
  <li><code class="highlighter-rouge">docker build</code> - create a custom image from a base image via a Dockerfile</li>
  <li>
    <p><code class="highlighter-rouge">docker rmi</code> - delete an image</p>
  </li>
  <li><code class="highlighter-rouge">docker ps -a</code> - list containers</li>
  <li><code class="highlighter-rouge">docker run</code> - creates and runs the specified image as a container (downloads it if not found and it can)</li>
  <li><code class="highlighter-rouge">docker create</code> - creates the container from the image</li>
</ul>

<h2 id="chapter-1-understanding-docker">Chapter 1 Understanding Docker</h2>

<h3 id="consistency-problem">Consistency Problem</h3>

<ul>
  <li>Differences in environment cause the application to behave differently e.g. no reverse proxy in development</li>
  <li>Differences in dependencies on version of dev tools e.g. .NET version</li>
  <li>Differences in the way the solution is deployed</li>
  <li>Ensuring all servers for an application are configured consistently</li>
</ul>

<h4 id="with-docker">With Docker</h4>

<ul>
  <li>Development image - differs only by containing compiler and debugger</li>
  <li>Production image - omits dev tools and has compiled version of classes</li>
</ul>

<h3 id="responsiveness-problem">Responsiveness Problem</h3>

<ul>
  <li>ASP.NET applications historically struggle to provision the right amount of capacity to deal with their workload</li>
</ul>

<h4 id="with-docker-1">With Docker</h4>

<ul>
  <li>The container provides a lightweight wrapper around the application. The application can be scaled horizontally by adding further containers when required.</li>
</ul>

<h3 id="containers-v-vms">Containers v VMs</h3>

<ul>
  <li>Containers only isolate applications but otherwise still depend on the underlying machine - linux containers can only run on linux VMs, windows on windows</li>
  <li>A single server can run more containers than VMs - fewer resources are spent on low level OS tasks</li>
</ul>

<h3 id="limitations">Limitations</h3>

<ul>
  <li>Containers work best for MVC applications which are stateless - any state data needs to be stored in such a way that it is accessible from each container (another container running redis?)</li>
  <li>If an application can’t be scaled via duplication the benefits of using containers diminishes</li>
  <li>Linux has mature support for Docker, but only Windows Server 2016 and Windows 10 (pre release versions only) support Docker</li>
  <li>.NET Core and ASP.NET Core both work on Linux and Linux containers are <strong>recommended</strong></li>
</ul>

<h3 id="other-containerisation-options">Other containerisation options</h3>

<ul>
  <li>Open Container Initiative aims to standardise the use of containers</li>
  <li>Main Docker competitor is <code class="highlighter-rouge">rkt</code> produced by CoreOS</li>
</ul>

<h2 id="chapter-2-essential-docker-quick-reference">Chapter 2 Essential Docker Quick Reference</h2>

<h3 id="images">Images</h3>

<p>The Docker image used to deploy ASP.NET Core applications does not contain the .NET Core compiler so the application must be compiled with all dependencies. Within the project folder of the application run to publish the output artefacts to a folder called <code class="highlighter-rouge">dist</code>.</p>

<p><code class="highlighter-rouge">dotnet publish --framework netcoreapp1.1 --configuration Release --output dist</code></p>

<p>Use <code class="highlighter-rouge">docker build</code> to build the image from a Docker file e.g. <code class="highlighter-rouge">docker build . -t apress/exampleapp -f Dockerfile</code> where <code class="highlighter-rouge">.</code> indicates the current directory as the working directory; <code class="highlighter-rouge">-t</code> is the name of the image; <code class="highlighter-rouge">-f</code> specifies the Docker file</p>

<table>
  <thead>
    <tr>
      <th>Command</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">docker build</code></td>
      <td>This command processes a Docker file and creates an image.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">docker images</code></td>
      <td>This command lists the images that are available on the local system. The <code class="highlighter-rouge">-q</code> argument returns a list of unique IDs that can be used with the docker rmi command to remove all images.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">docker pull</code></td>
      <td>This command downloads an image from a repository (often don’t need to run explicitly)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">docker push</code></td>
      <td>This command publishes an image to a repository. You may have to authenticate with the repository using the <code class="highlighter-rouge">docker login</code> command.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">docker tag</code></td>
      <td>This command is used to associate an (alternative) name with an image.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">docker rmi</code></td>
      <td>This command removes images from the local system (specifying the image ID). The -f argument can be used to remove images for which containers exist. To remove all images use <code class="highlighter-rouge">docker rmi -f $(docker images -q)</code> to pump all images IDs to the <code class="highlighter-rouge">rmi</code> command.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">docker inspect</code></td>
      <td>Displays details about the image</td>
    </tr>
  </tbody>
</table>

<p>Useful prebuilt images include images containing: ASP.NET Core runtime; .NET Core runtime; .NET Core SDK (for development); MySQL; HAProxy, useful as a load balancer / configured to respond to containers starting and stopping</p>

<p>Docker files contain a series of commands including:</p>

<ul>
  <li>FROM - specify base image;</li>
  <li>WORKDIR - change the working dir for subsequent commands;</li>
  <li>COPY - add files to become part of the container’s file system;</li>
  <li>RUN - execute command e.g download dependencies</li>
  <li>EXPOSE - expose a port from the container</li>
  <li>ENV - create environment vars</li>
  <li>VOLUME -</li>
  <li>ENTRYPOINT - the application to be run</li>
</ul>

<h3 id="containers">Containers</h3>

<p>Containers are created from an image and used to execute an application in isolation.</p>

<ul>
  <li>Create using <code class="highlighter-rouge">docker create</code> and start using <code class="highlighter-rouge">docker start</code> - or create and start using <code class="highlighter-rouge">docker run</code> e.g. <code class="highlighter-rouge">docker run -p 4000:80 --name exampleApp4000 apress/exampleapp</code>.</li>
  <li>Arguments passed in allow containers from the same image to be configured differently
    <ul>
      <li><code class="highlighter-rouge">--env</code> or <code class="highlighter-rouge">-e</code> for environment vars;</li>
      <li><code class="highlighter-rouge">--publish</code> or <code class="highlighter-rouge">-p</code> to map a port;</li>
      <li><code class="highlighter-rouge">--network</code> to join a container to a software defined network;</li>
      <li><code class="highlighter-rouge">--rm</code> to remove a container when it stops</li>
      <li><code class="highlighter-rouge">--volume</code> or <code class="highlighter-rouge">-v</code> to define a directory on the host available on the container’s filesystem</li>
    </ul>
  </li>
</ul>

<p>Other useful commands include:</p>

<ul>
  <li><code class="highlighter-rouge">docker ps</code> to list containers</li>
  <li><code class="highlighter-rouge">docker logs</code> to inspect the logs</li>
  <li><code class="highlighter-rouge">docker exec</code> to execute a command inside the container</li>
</ul>

<h3 id="volumes">Volumes</h3>

<p>Volumes allow data files to be stored outside of a container, which means they are not deleted when the container is deleted or updated.</p>

<ul>
  <li>Volumes are created using <code class="highlighter-rouge">docker volume create</code> and assigned a name e.g. `
docker volume create –name productdata`</li>
  <li>The name is applied in the <code class="highlighter-rouge">docker create</code> command e.g. <code class="highlighter-rouge">docker run --name mysql -v productdata:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=mysecret -e
bind-address=0.0.0.0 mysql:8.0.0</code></li>
</ul>

<h3 id="software-defined-networks">Software-Defined Networks</h3>

<p>Software-defined networks are used to connect containers together, using networks that are created and managed using Docker.</p>

<ul>
  <li>Create using <code class="highlighter-rouge">docker network create backend</code></li>
  <li>Join a container to a network using the <code class="highlighter-rouge">--network</code> parameter of the <code class="highlighter-rouge">docker create</code> command or the <code class="highlighter-rouge">docker network connect</code> command</li>
  <li>Use <code class="highlighter-rouge">ls</code> and <code class="highlighter-rouge">rm</code> to list and remove networks</li>
</ul>

<h3 id="compose">Compose</h3>

<p>Docker Compose is used to describe complex applications that require multiple containers, volumes, and software-defined networks, using the YAML format.</p>

<ul>
  <li>Compose files are processed using the <code class="highlighter-rouge">docker-compose build</code> command e.g. <code class="highlighter-rouge">docker-compose -f docker-compose.yml build</code></li>
  <li>Use <code class="highlighter-rouge">docker-compose up</code> to create the containers, networks and volumes specified</li>
</ul>

<p>Other useful commands include:</p>

<ul>
  <li><code class="highlighter-rouge">docker-compose stop</code> to stop containers created from services in a compose file</li>
  <li><code class="highlighter-rouge">docker-compose down</code> to stop and delete containers, networks and volumes</li>
  <li><code class="highlighter-rouge">docker-compose scale</code> to scale the number of containers running</li>
  <li><code class="highlighter-rouge">docker-compose ps</code> to list the containers created</li>
</ul>

<h3 id="swarm">Swarm</h3>

<p>A Docker swarm is a cluster of servers that run containers. Worker nodes run the containers and manager nodes distribute the containers between nodes.</p>

<ul>
  <li><code class="highlighter-rouge">docker swarm init</code> from a manager node</li>
  <li><code class="highlighter-rouge">docker swarm join</code> from a worker node (using details output in previous command)</li>
  <li>Compose files can be used to define the services in a swarm</li>
  <li>Use <code class="highlighter-rouge">docker stack deploy</code> to deploy such an application e.g. <code class="highlighter-rouge">docker stack deploy --compose-file docker-compose-swarm.yml exampleapp</code> (where <code class="highlighter-rouge">exampleapp</code> gets used a s prefix to the names)</li>
</ul>

<h2 id="chapter-4-docker-images-and-containers">Chapter 4 Docker Images and Containers</h2>

<ul>
  <li><code class="highlighter-rouge">docker logs</code> to see the last set of logs from a container (whether still running or stopped)</li>
  <li><code class="highlighter-rouge">docker logs -f</code> to see continuous output</li>
  <li><code class="highlighter-rouge">docker cp host-file exampleApp3000:/app/</code> to copy files into a container (use with caution)</li>
  <li><code class="highlighter-rouge">docker diff</code> to see differences between a container and the image it was created from (A=added; C=changed; D=deleted)</li>
  <li><code class="highlighter-rouge">docker exec exampleApp3000 [command]</code> to execute a command in a container</li>
  <li><code class="highlighter-rouge">docker exec -it exampleApp3000 /bin/bash</code> to start an interactive shell (Bash is included in aspnetcore images)</li>
  <li><code class="highlighter-rouge">apt update &amp;&amp; apt install vim</code> to install packages</li>
</ul>

<h3 id="creating-images-from-modified-containers">Creating Images from Modified Containers</h3>

<p>Either run an existing container, or run a dynamic container from an image using:</p>

<p><code class="highlighter-rouge">docker run -it microsoft/dotnet:2.1-aspnetcore-runtime /bin/bash</code> to create a container, start it and enter an interactive shell</p>

<p>Make any changes and exit. After exiting run <code class="highlighter-rouge">docker ps -a</code> to see the container. The name will be randomly generated for the container in this last case. See https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go</p>

<p>Create a new image from the container using <code class="highlighter-rouge">docker commit</code>:</p>

<p><code class="highlighter-rouge">docker commit hungry_torvalds infuerno/dotnet:2.1-aspnetcore-runtime</code></p>

<h3 id="publishing-images">Publishing Images</h3>

<ul>
  <li><code class="highlighter-rouge">docker login -u username -p password</code></li>
  <li><code class="highlighter-rouge">docker push username/image:version</code></li>
  <li><code class="highlighter-rouge">docker logout</code></li>
</ul>

<h2 id="chapter-5-docker-volumes-and-networks">Chapter 5 Docker Volumes and Networks</h2>

<ul>
  <li>Volumes - allow important data to exist outside of the container, allow changing or upgrading containers without loosing data</li>
  <li>
    <p>Networks - IP docker networks for container communication on a single server (between servers only IF a cluster is used)</p>
  </li>
  <li><code class="highlighter-rouge">docker volume create --name testdata</code> - create a new volume</li>
  <li><code class="highlighter-rouge">docker run --name vtest2 -v testdata:/data infuerno/vtest</code> - create a container which maps the volume <code class="highlighter-rouge">testdata</code> to <code class="highlighter-rouge">/data</code></li>
</ul>
:ET