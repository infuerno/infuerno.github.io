I"ß<h2 id="overview">Overview</h2>

<ul>
  <li>Lots of new functionality added in Web API v2</li>
  <li>In v1 security was mainly based on hosting specific features</li>
  <li>In v2 new hosting and authentication infrastructures, lots of options around authorisation</li>
</ul>

<h2 id="http-security-primer">HTTP Security Primer</h2>

<h3 id="transport-security-securing-over-the-wire">Transport security (securing over the wire)</h3>

<ul>
  <li>HTTP has no built in security</li>
  <li>HTTPS = HTTP over TLS</li>
  <li>TLS or SSL is a tunneling protocol where you can tunnel insecure protocols over a secure tunnel</li>
  <li>Features this gives us:
    <ul>
      <li>Server authentication - SSL handshake ensures you are talking to the right server</li>
      <li>Integrity protection - want to make sure that when you send information to the server, no one can tamper with that message on the way</li>
      <li>Replay protection - e.g. message to buy something canâ€™t be replayed so that you end up buying it multiple times</li>
      <li>Confidentiality i.e. encryption</li>
    </ul>
  </li>
  <li>Magic ingredient are the certificates, the X.509 certificates - owner, issuer, validity, public key - in the context of SSL, the certificate is typically issued to the web server</li>
  <li>The private key is not part of the certificate - should ideally never leave the server</li>
</ul>

<h3 id="simplified-ssl-handshake">Simplified SSL handshake</h3>

<p>All the gory details: http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html</p>

<ul>
  <li>Connect to an HTTPS website</li>
  <li>Server sends back certificate to the browser
    <ul>
      <li>Checks DNS name = server server certificate name</li>
      <li>Do we trust the issuer?</li>
      <li>Is the certificate still valid</li>
      <li>Also checks a revocation list (CRL) i.e. blacklisted certificates to ensure it isnâ€™t on this list</li>
    </ul>
  </li>
  <li>If everything ok, browser generates a session key (random key)</li>
  <li>To transmit this securely, it encrypts it with the public key from the SSL certificate - only the server with the private key can decrypt the session key and then communicate with the client</li>
  <li>From then all comms is symmetrically signed with the key</li>
</ul>

<h3 id="developers-and-ssl">Developers and SSL</h3>

<p>If you Google SSL issues, you often get answers on how to ignore the errors. If you do this, it is like not using SSL at all - which can be very dangerous. e.g. donâ€™t use the ServicePointManager API allows you to ignore all validation errors</p>

<h3 id="where-to-get-certificates-from">Where to get Certificates from</h3>

<ol>
  <li>Buy a certificate - choose a popular provider e.g. Verisign - prove your identity, that you own the domain, pay some money - they will send you a certificate and the corresponding private key
    <ul>
      <li>implicitly trusted by all clients</li>
      <li>zero configuration on the client side</li>
      <li>pay money</li>
    </ul>
  </li>
  <li>Corporate PKI - only for applications which are intranet facing or used by members of that company. Easy to set up using Windows Certificate Services.</li>
  <li>Create yourself - create own certificate infrastructure by building your own issuer and then creating your own certificates - uses makecert.exe (openssl can be used on a mac)</li>
</ol>

<h4 id="creating-a-root-certificate">Creating a Root Certificate</h4>

<p>The following will create a root certificate - in order to create other certificates. This approach means you only need to trust this certificate, and you will then trust all other certificates created from this.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>makecert.exe
    -r                  // self signed
    -n "CN=DevRoot"     // name
    -pe                 // exportable
    -sv DevRoot.pvk     // name of private key file
    -a sha1             // hashing algorithm
    -len 2048           // key length
    -b 01/22/2010       // valid from
    -e 01/22/2030       // valid to
    -cy authority       // certificate type
    DevRoot.cer         // name of certificate file
</code></pre></div></div>

<h3 id="creating-an-ssl-certificate">Creating an SSL Certificate</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>makecert.exe
    -iv DevRoot.pvk     // file name of the root private key
    -ic DevRoot.cer     // file name of the root cer
    -n "CN=DevRoot"     // name
    -pe                 // exportable
    -sv web.local.pvk   // name of private key file
    -a sha1             // hashing algorithm
    -len 2048           // key length
    -b 01/22/2010       // valid from
    -e 01/22/2030       // valid to
    -sky exchange       // certificate type
    web.local.cer       // name of certificate file
    -eku 1.3.6.1.5.5.7.3.1 // extended key usage
</code></pre></div></div>

<h3 id="http-authentication-framework-how-do-you-submit-credentials">HTTP authentication framework (how do you submit credentials)</h3>
:ET