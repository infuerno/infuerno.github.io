I"¯â<h2 id="references">References</h2>
<ul>
  <li>https://blogs.msmvps.com/deborahk/angular-2-getting-started-problem-solver/</li>
  <li>https://github.com/DeborahK/Angular-GettingStarted</li>
  <li>https://www.typescriptlang.org/play/</li>
  <li>Course to learn TypeScript: TypeScript Fundamentals</li>
  <li>Course to learn VS Code: Visual Studio Code</li>
  <li>Course to learn more about HTTP: Angular: Reactive Forms</li>
  <li>Course to learn more about RxJS: RxJS in Angular: Reactive Development</li>
  <li>Course to learn advanced HTTP: Angular HTTP Communication</li>
</ul>

<h1 id="introduction">Introduction</h1>
<ul>
  <li>Application made up of lots of components and possibly services</li>
  <li>Component = template + class (properties and methods) + metadata</li>
  <li>Modules allow organising components into cohesive blocks</li>
  <li>Each application has a least one: Root Module</li>
</ul>

<h2 id="components-in-the-example-application">Components in the example application</h2>
<ul>
  <li>Welcome page -&gt; Welcome Component</li>
  <li>Product list page -&gt; Product List Component</li>
  <li>Star ratings (reusable) -&gt; nestable Star Component</li>
  <li>Product detail page -&gt; Product Detail Component</li>
  <li>App Component to tie things together</li>
  <li>Product Data Service to get any data</li>
  <li>index.html</li>
</ul>

<h1 id="first-things-first">First Things First</h1>
<ul>
  <li>Install NPM (NodeJS)</li>
  <li><code class="highlighter-rouge">npm install</code></li>
  <li><code class="highlighter-rouge">npm start</code></li>
</ul>

<h2 id="references-1">References</h2>
<ul>
  <li>Angular CLI - https://github.com/angular/angular-cli</li>
  <li>Starter files - https://github.com/deborahk/angular-gettingstarted</li>
</ul>

<h2 id="building-and-running-the-initial-application">Building and running the initial application</h2>
<ul>
  <li><code class="highlighter-rouge">src</code> - all source code files in a directory named <code class="highlighter-rouge">src</code></li>
  <li><code class="highlighter-rouge">src/app</code> - source code specific to the application; subfolder for each major feature in the application</li>
  <li>Other files under <code class="highlighter-rouge">src</code> are setup and configuration files  = boilerplate files</li>
  <li><code class="highlighter-rouge">npm install</code> to install all dependencies in <code class="highlighter-rouge">package.json</code> (creates a new folder <code class="highlighter-rouge">node_modules</code> - ensure in .gitignore)</li>
</ul>

<h2 id="modules">Modules</h2>

<h3 id="es-2015-modules">ES 2015 Modules</h3>
<ul>
  <li>ES 2015 defines a module as a file and a file as a module</li>
  <li>Angular has an implementation of ES 2015 Modules, but ALSO has Angular Modules</li>
  <li>ES 2015 Modules:
    <ul>
      <li>product.ts - <code class="highlighter-rouge">export class Product { ... }</code> - this file becomes a module and exports the class <code class="highlighter-rouge">Product</code></li>
      <li>product-list.ts - <code class="highlighter-rouge">import { Product } from './product'</code> - this file also becomes a module since it imports the <code class="highlighter-rouge">Product</code> module</li>
    </ul>
  </li>
  <li>Note - <code class="highlighter-rouge">product.ts</code> will be transpiled to <code class="highlighter-rouge">product.js</code> (but anyway the file extension is not included when importing modules)</li>
</ul>

<h3 id="angular-modules">Angular Modules</h3>
<ul>
  <li>Has at least one Root Angular Module (by convention called app module)</li>
  <li>When adding more features - can be grouped into seperate Feature Modules</li>
  <li>Can also defined Shared or Common Modules</li>
  <li>Each Component is declared in and belongs to ONE and ONLY ONE Module</li>
</ul>

<table>
  <thead>
    <tr>
      <th>ES Modules</th>
      <th>Angular Modules</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Code files that import or export something</td>
      <td>Code files that organise the application into cohesive blocks of functionality</td>
    </tr>
    <tr>
      <td>Organise our code files</td>
      <td>Organise our application</td>
    </tr>
    <tr>
      <td>Modularise our code</td>
      <td>Modularise our application</td>
    </tr>
    <tr>
      <td>Promote code reuse</td>
      <td>Promote application boundaries</td>
    </tr>
  </tbody>
</table>

<h1 id="introduction-to-components">Introduction to Components</h1>
<p>What is a component? Creating a component class. Defining metadata with a decorator. Importing dependencies. Bootstrap the app component.</p>

<ul>
  <li>Component = template + class + metadata</li>
  <li>Convention is to name components ending in <code class="highlighter-rouge">Component</code> and for the root component to be called <code class="highlighter-rouge">AppComponent</code></li>
  <li><code class="highlighter-rouge">export</code> enables other files / classes to use this component (and thus makes it an ES module)</li>
  <li>A class becomes an Angular Component when it is given component metadata using an <code class="highlighter-rouge">@Component</code> decorator function (similar to attributes in other languages):
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">({</span>
<span class="na">selector</span><span class="p">:</span> <span class="dl">'</span><span class="s1">pm-root</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// Directive Name (simply a custom HTML tag)</span>
<span class="na">template</span><span class="p">:</span> <span class="s2">`&lt;div&gt;&lt;h1&gt;&lt;/h1&gt;&lt;/div&gt;`</span>
<span class="p">})</span>
</code></pre></div>    </div>
    <p>This a function (hence <code class="highlighter-rouge">()</code>) which is passed an anonymous object (hence <code class="highlighter-rouge">{}</code>)</p>
  </li>
  <li>All external modules or classes need to be <code class="highlighter-rouge">import</code>ed prior to using (part of ES 2015) - allows using <code class="highlighter-rouge">export</code>ed members from external modules</li>
  <li>Angular is modular: @angular/core; @angular/animate; @angular/common; @angular/router - anything needed from angular needs to be imported (see all available libraries at https://www.npmjs.com/search?q=@angular)</li>
  <li>Bootstrap the root app component:
    <ul>
      <li><code class="highlighter-rouge">index.html</code> hosts the application - the file contains the root component‚Äôs directive e.g. <code class="highlighter-rouge">&lt;pm-root&gt;&lt;/pm-root&gt;</code>. As soon as the page has finished loading the template‚Äôs HTML is inserted between these tags</li>
      <li>The HTML file knows about the custom directive by checking with an Angular Module. The root angular module declares the root component and is also able to bootstrap the startup component (usually named <code class="highlighter-rouge">AppComponent</code>)</li>
      <li>Example root angular module:</li>
    </ul>
  </li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">NgModule</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@angular/core</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">BrowserModule</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@angular/platform-browser</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">AppComponent</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./app-component</span><span class="dl">'</span><span class="p">;</span>

<span class="p">@</span><span class="nd">NgModule</span><span class="p">({</span>
  <span class="na">imports</span><span class="p">:</span> <span class="p">[</span> <span class="nx">BrowserModule</span> <span class="p">],</span> <span class="c1">// arrays</span>
  <span class="na">declarations</span><span class="p">:</span> <span class="p">[</span> <span class="nx">AppComponent</span> <span class="p">],</span>
  <span class="na">bootstrap</span><span class="p">:</span> <span class="p">[</span> <span class="nx">AppComponent</span> <span class="p">]</span>
<span class="p">})</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">AppModule</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Use PascalCasing for classes</li>
  <li>Use camelCasing for properties and methods</li>
</ul>

<h1 id="templates-interpolation-and-directives">Templates, Interpolation and Directives</h1>
<ul>
  <li><code class="highlighter-rouge">npm install bootstrap font-awesome</code></li>
  <li>Import bootstrap and font-awesome css files into the main <code class="highlighter-rouge">styles.css</code></li>
  <li>Binding co-ordinates communication between the component‚Äôs class and its template and often involves passing data. Provide values from the class to the template for display; the template raises events to pass user actions or user entered values back to the class.</li>
  <li>Interpolation - one type of binding - <strong>one way binding</strong> - from class -&gt; template - can use concatenation, calculations, call methods etc</li>
  <li>Note - quotes not needed on HTML attributes when using interpolation</li>
  <li>The syntax between <code class="highlighter-rouge">{{ }}</code> is called a <strong>template expression</strong></li>
</ul>

<h2 id="for--of-vs-for--in">for .. of vs for .. in</h2>
<ul>
  <li>ES 2015 has both loops
    <ul>
      <li><code class="highlighter-rouge">for .. of</code> iterates over iterable objects e.g. objects in an array</li>
      <li><code class="highlighter-rouge">for .. in</code> iterates over the properties of an object e.g. indexes in an array</li>
    </ul>
  </li>
</ul>

<p>Hence <code class="highlighter-rouge">*ngFor</code> uses <code class="highlighter-rouge">for .. of</code></p>

<h1 id="data-binding--pipes">Data Binding &amp; Pipes</h1>
<ul>
  <li>Interpolation</li>
  <li>Property Binding</li>
  <li>Event Binding</li>
  <li>Two-way binding</li>
</ul>

<h2 id="property-binding">Property Binding</h2>
<ul>
  <li>One way binding</li>
  <li><code class="highlighter-rouge">&lt;img [src]='product.imageUrl'&gt;</code> - set the property of an element to the value of a template expression</li>
  <li>Binding target is always enclosed in <code class="highlighter-rouge">[]</code></li>
  <li>Binding source is always enclosed in <code class="highlighter-rouge">''</code></li>
  <li>Alternative using interpolation: <code class="highlighter-rouge">&lt;img src=&gt;</code></li>
</ul>

<h2 id="event-binding">Event Binding</h2>
<ul>
  <li>One way binding from template -&gt; class</li>
  <li>Source binding event is enclosed in <code class="highlighter-rouge">()</code></li>
  <li>Binding target is often a class method and enclosed in <code class="highlighter-rouge">''</code></li>
  <li>See: https://developer.mozilla.org/docs/Web/Events for a list of DOM events</li>
</ul>

<h2 id="two-way-binding">Two-way Binding</h2>
<ul>
  <li>Use the <code class="highlighter-rouge">ngModel</code> directive which is enclosed in both <code class="highlighter-rouge">[]</code> and <code class="highlighter-rouge">()</code> i.e. <code class="highlighter-rouge">[(ngModel)]</code> (a Banana in a Box)</li>
  <li><code class="highlighter-rouge">&lt;input type='text' [(ngModel)]='filterText'/&gt;</code></li>
  <li>Specify the binding source of the class in quotes</li>
  <li><code class="highlighter-rouge">ngModel</code> is part of <code class="highlighter-rouge">FormsModule</code> so needs to be imported in the appropriate component</li>
</ul>

<h2 id="pipes">Pipes</h2>
<ul>
  <li><code class="highlighter-rouge">| uppercase</code></li>
  <li><code class="highlighter-rouge">| currency | lowercase</code></li>
  <li>Pipes with parameters: <code class="highlighter-rouge">| currency:'USD':'symbol':'1.2-2'</code></li>
</ul>

<h1 id="more-on-components">More on Components</h1>
<ul>
  <li>Predefine types using an interface</li>
  <li>Encasulate styles within components with a dedicated stylesheet</li>
  <li>Lifecycle hooks</li>
  <li>Custom pipes</li>
  <li>Nested components for reuse</li>
</ul>

<h2 id="interfaces">Interfaces</h2>
<ul>
  <li>Used to define datatypes</li>
  <li>ES5 and ES2015 do not support interfaces - but TypeScript does, so only provide compile time support</li>
  <li>Many prefix interface names with<code class="highlighter-rouge">I</code> e.g. <code class="highlighter-rouge">IProduct</code></li>
  <li>Can also create a class to implement that interface but ONLY IF the class provides some functionality we want to use throughout the application e.g. the interface defines a method</li>
</ul>

<h2 id="component-styles">Component styles</h2>
<ul>
  <li>Use the <code class="highlighter-rouge">styles</code> or <code class="highlighter-rouge">styleUrls</code> properties on the <code class="highlighter-rouge">@Component</code> decorator (both array types so can specify multiple styles, or multiple files)</li>
</ul>

<h2 id="component-lifecycle">Component lifecycle</h2>
<ul>
  <li>Create -&gt; Render -&gt; Create and render children -&gt; Process changes (when the databound properties change) -&gt; Destroy it before moving its template from the DOM</li>
  <li>Lifecycle hooks can be used to tap into these steps
    <ul>
      <li><code class="highlighter-rouge">OnInit</code> (method is <code class="highlighter-rouge">ngOnInit</code>) for component initialization after Angular has initialised the databound properties e.g. retrieve data from backend service</li>
      <li><code class="highlighter-rouge">OnChanges</code> perform actions after Angular sets databound input properties (input properties coming up)</li>
      <li><code class="highlighter-rouge">OnDestroy</code> for cleanup</li>
    </ul>
  </li>
  <li>There is an interface for each lifecycle hook which the Component class can implement as required
    <ul>
      <li>Declare the class implements the interface</li>
      <li>Import it</li>
      <li>Write the method</li>
    </ul>
  </li>
  <li>Note that since JavaScript does not support interfaces - they are only checked at compile time and aren‚Äôt strictly necessary - nevertheless it is good practice.</li>
</ul>

<h2 id="custom-pipes">Custom Pipes</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Pipe({
  name: 'convertToSpaces'
})
export class ConvertToSpacesPipe implements PipeTransform {
  transform(value: string, character: string): string {
    return value.replace(character, ' ');
  }
}
</code></pre></div></div>
<ul>
  <li>New file e.g. <code class="highlighter-rouge">convert-to-spaces.pipe</code> in the shared folder</li>
  <li>Import <code class="highlighter-rouge">Pipe</code> and <code class="highlighter-rouge">PipeTransform</code> from <code class="highlighter-rouge">@anglar/core</code></li>
  <li>Add the pipe class name to the <code class="highlighter-rouge">declarations</code> list in the appropriate Angular module as well as the necessary import statement to the location of the code file</li>
</ul>

<h2 id="filtering">Filtering</h2>
<ul>
  <li>Could use a pipe - but Angular doesn‚Äôt provide such functionality ‚Äúthey perform poorly and prevent agressive minification‚Äù (https://angular.io/guide/pipes#no-filter-pipe)</li>
  <li>Recommendation is to move sorting and filtering logic into the component</li>
  <li>Could use event binding on key presses etc - but an EASIER way is to change the existing <code class="highlighter-rouge">listFilter</code> public property into a getter and setter backed by a private property</li>
  <li>In all other respects this works exactly as the existing property - however now we can add extra logic into the getters or setters e.g. update an seperate <code class="highlighter-rouge">filteredProducts</code> array when the value is changed e.g. <code class="highlighter-rouge">this.filteredProducts = list.listFilter ? this.performFilter(this.listFilter) : this.products;</code></li>
  <li>Also a good idea to set default values in the constructor e.g. <code class="highlighter-rouge">this.listFilter = 'cart'; this.filteredProducts = this.products;</code></li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>performFilter(filterBy: string): IProduct[] {
  filterBy = filterBy.ToLocaleLowerCase();
  return this.products.filter((product: IProduct) =&gt;
  product.name.ToLocaleLowerCase().indexOf(filterBy) !== -1);
}
</code></pre></div></div>
<p>See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter</p>

<h1 id="building-nested-components">Building Nested Components</h1>
<p><img src="https://www.dropbox.com/s/8utbo2z4p8d7ynz/Screenshot%202019-08-19%2010.12.55.png?raw=1" alt="Building a Nested Component" /></p>

<ul>
  <li>Components are completely encapsulated and can then define inputs (property with <code class="highlighter-rouge">@Input</code> decorator) and outputs (raise event using <code class="highlighter-rouge">@Output</code>) for them to pass data back and forth</li>
  <li>EITHER nest a component using a directive</li>
  <li>OR use a component as a routing target</li>
</ul>

<h3 id="input-using-star-component">Input using Star component</h3>
<ul>
  <li>Create a new component with two properties <code class="highlighter-rouge">rating: number</code> and <code class="highlighter-rouge">starWidth: number</code> which is calculated based on the rating</li>
  <li>Mark the <code class="highlighter-rouge">rating</code> property with the <code class="highlighter-rouge">@Input()</code>  decorator i.e. <code class="highlighter-rouge">@Input() rating: number</code></li>
  <li>Implement the <code class="highlighter-rouge">OnChanges</code> interface so the <code class="highlighter-rouge">starWidth</code> value can be updated any time the container changed the rating.</li>
  <li>Add the <code class="highlighter-rouge">ngOnChanges</code> method and implement the calculation of <code class="highlighter-rouge">starWidth</code></li>
  <li>Finally update the containing component to nest the star component and pass the input property: <code class="highlighter-rouge">&lt;td&gt;&lt;pm-star [rating]='product.starRating'&gt;&lt;/pm-star&gt;&lt;/td&gt;</code></li>
</ul>

<h3 id="output">Output</h3>
<ul>
  <li><code class="highlighter-rouge">@Output()</code> decorator can be prepended to a property, but the type of the property must be an Event. The data to pass then becomes the Event payload. <code class="highlighter-rouge">EventEmitter&lt;T&gt;</code> is Angular‚Äôs event object e.g. <code class="highlighter-rouge">EventEmitter&lt;string&gt;</code></li>
  <li>e.g. <code class="highlighter-rouge">@Output() notify: EventEmitter&lt;string&gt; = new EventEmitter&lt;string&gt;();</code></li>
  <li>On the component HTML add the event: <code class="highlighter-rouge">&lt;div (click)='onClick()'&gt;&lt;/div&gt;</code></li>
  <li>In the <code class="highlighter-rouge">StarComponent</code> define the <code class="highlighter-rouge">onClick()</code> method e.g. <code class="highlighter-rouge">this.notify.emit('clicked ...');</code></li>
  <li>This event will be raised to the containing component</li>
  <li>This event can then be received using <code class="highlighter-rouge">(notify)='onNotify($event);</code> on the nested component HTML e.g. <code class="highlighter-rouge">&lt;pm-star [rating]='product.starRating' (notify)='onNotify($event)'&gt;&lt;/pm-star&gt;</code></li>
  <li>Lastly, implement the <code class="highlighter-rouge">onNotify</code> method in the parent container</li>
</ul>

<h1 id="services-and-dependency-injection">Services and Dependency Injection</h1>
<ul>
  <li>A Service is a class with  a focused purpose independent of any component - provide shared data or cross cutting concerns like logging</li>
  <li>Angular DI container <strong>Injector</strong> creates singletons - since this instance is shared, any data or logic is shared with all components</li>
  <li>There is a <code class="highlighter-rouge">Root Injector</code> container available to all components</li>
  <li>There is also an <code class="highlighter-rouge">Injector</code> available to each component (and its child or nested components)</li>
  <li>How its registered depends on which Injector is used
    <ul>
      <li>if it is the root injector, this can be specified in the service itself by using the <code class="highlighter-rouge">providedIn: 'root</code> property on the <code class="highlighter-rouge">@Injectible()</code> decorator</li>
      <li>in a single component use the <code class="highlighter-rouge">providers</code> property of the <code class="highlighter-rouge">@Component</code> decorator i.e. <code class="highlighter-rouge">providers: [ProductService]</code></li>
      <li>NOTE previous to Angular 6 to register with root, it was registered using the <code class="highlighter-rouge">provider</code> property of the root <code class="highlighter-rouge">NgModule</code> in <code class="highlighter-rouge">app.module.ts</code> (new way is better for tree shaking)</li>
    </ul>
  </li>
</ul>

<h1 id="retrieving-data-using-http">Retrieving Data Using HTTP</h1>
<h2 id="observables">Observables</h2>
<p>Reactive extensions (RxJS) represent a data sequence as an observable sequence, ‚Äúan observable‚Äù.</p>
<ul>
  <li>An array with items which arrive asynchronously over time</li>
  <li>Can subscribe to receive notifications when new items arrive, there is no more data or when an error occurs.</li>
  <li>Operators transform the source data in some way, and process each value as it comes e.g. <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">filter</code>, <code class="highlighter-rouge">take</code>, <code class="highlighter-rouge">merge</code></li>
  <li>e.g. multiple each value by 10: <code class="highlighter-rouge">map(x =&gt; 10 * x)</code></li>
  <li>See https://rxmarbles.com for ‚Äúmarble diagrams‚Äù of Rx Observables</li>
  <li>Variables holding observables have a <code class="highlighter-rouge">$</code> suffix by convention e.g. <code class="highlighter-rouge">source$: Observable&lt;number&gt; = range(0, 10)</code></li>
  <li><code class="highlighter-rouge">pipe()</code> the values through any observable operators</li>
  <li><code class="highlighter-rouge">subscribe()</code> to receive values - no values will be emitted unless subscribed to, so this is KEY
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source$.pipe(
map(x =&gt; x * 3),
filter(x =&gt; x % 2 == 0)
).subscribe(x =&gt; console.log(x));
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="promise-vs-observable">Promise vs Observable</h2>
<p>Promise | Observable
‚Äî|‚Äî
Provides a single future value | Emits multiple values over time
Lazy | Not lazy
Not cancellable | Cancellable - by unsubscribing</p>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Supports map, filter, reduce and similar operators</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h2 id="exception-handling">Exception Handling</h2>
<p>Many things can go wrong when communicating with a backend service e.g. invalid request, lost connection. Two observable operators to help with exception handling are <code class="highlighter-rouge">tap</code> and <code class="highlighter-rouge">catchError</code></p>
<ul>
  <li><code class="highlighter-rouge">tap</code> enables looking at the values in the stream without transforming - useful for logging</li>
  <li><code class="highlighter-rouge">catchError</code> catches any errors</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getProducts(): Observable&lt;IProduct[]&gt; {
  return this.http.get&lt;IProduct[]&gt;(this.productUrl).pipe(
    tap(data =&gt; console.log('All: ' + JSON.stringify(data))),
    catchError(this.handleError)
  );
}

private handleError(err: HttpErrorResponse): Observable&lt;never&gt; {
 ... // log to remote logging; throw to calling code etc
 let errorMessage = '';
 if (err.error instanceOf ErrorEvent) {
   errorMessage = `An error occurred: ${err.error.message}`;
 } else {
   errorMessage = `Server return code: ${err.status}, error message is: ${err.message}`;
 } 
 console.log(errorMessage);
 return throwError(errorMessage);
}
</code></pre></div></div>
<h2 id="subscribing-to-an-observable">Subscribing to an Observable</h2>
<ul>
  <li>Need to subscribe to get values using <code class="highlighter-rouge">subscribe()</code></li>
  <li>Optionally takes an <code class="highlighter-rouge">Observer</code> object which is comprised of 3 functions, a next function, an error function and a complete function e.g. <code class="highlighter-rouge">subscribe({ nextFunc, errorFunc, completeFunc})</code> (where the functions can be expressed inline using =&gt; syntax)</li>
  <li>HTTP calls are <strong>single</strong> async operations so the value emitted will be <strong>one</strong> item, an array</li>
  <li>Complete function is rarely used with HTTP requests, since they automatically complete after emitting the single response</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>this.productService.getProducts().subscribe({
  next: p =&gt; this.products = p,
  error: err =&gt; this.errorMessage = err
});

// ALTERNATIVE SYNTAX introduced in ES 2015
this.productService.getProducts().subscribe({
  next(p) { this.products = p },
  error(err) { this.errorMessage = err }
});

</code></pre></div></div>

<h1 id="navigation-and-routing-basics">Navigation and Routing Basics</h1>
<ul>
  <li>Configure a route for each component which wants to be displayed in the SPA</li>
  <li>Menus link to the various options, user clicks on a menu, activate the route</li>
  <li>Achieved via <code class="highlighter-rouge">routerLink</code> directive e.g. <code class="highlighter-rouge">&lt;a routerLink='/products'&gt;Products&lt;/a&gt;</code> (uses HTML5 style URLs and therefore have to configure web server to perform URL rewriting - hash style routing is also possible e.g. https://site/#/products - this DOESN‚ÄôT require URL rewriting)</li>
  <li>Routing is component based</li>
  <li>An angular application has ONE router, managed by angular‚Äôs router service</li>
  <li>The external <code class="highlighter-rouge">RouterModule</code> provides the router service - import it and add it to the array of modules</li>
  <li>Call the <code class="highlighter-rouge">RouterModule</code>‚Äôs <code class="highlighter-rouge">forRoot()</code> method to register your routes</li>
  <li>Use <code class="highlighter-rouge">RouterModule.forRoot([], {useHash: true})</code> to use the hash based routing</li>
  <li>Example route definitions:</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[
  { path: 'products',  component: ProductListComponent },
  { path: 'products/:id', component: ProductDetailComponent },
  { path: 'welcome', component: WelcomeComponent },
  { path: '', redirectTo: 'welcome', pathMatch: 'full' },
  { path: '**', component: PageNotFoundComponent } // no other routes match
]
</code></pre></div></div>

<ul>
  <li>First match win strategy when matching routes</li>
  <li>Don‚Äôt use forward slashes at the beginning (why??!)</li>
</ul>

<h3 id="configuring-routes">Configuring routes</h3>
<ol>
  <li>Set up a <code class="highlighter-rouge">base</code> tag in the index.html e.g. <code class="highlighter-rouge">&lt;base href="/"&gt;</code></li>
  <li>Add the <code class="highlighter-rouge">RouterModule</code> in the root app module</li>
  <li>Configure routes on the import by calling <code class="highlighter-rouge">RouterModule.forRoot([])</code> and passing in the list of routes</li>
  <li>Add a menu and use routerLink directives bound to template expressions returning link parameter arrays e.g. <code class="highlighter-rouge">&lt;a [routerLink]="['/welcome']"&gt;Home&lt;/a&gt;</code> - the first element is the route, can also add optional route params
    <ul>
      <li>NOTE: can also use the shorthand: <code class="highlighter-rouge">&lt;a routerLink="/welcome"&gt;Home&lt;/a&gt;</code></li>
    </ul>
  </li>
  <li>Add the <code class="highlighter-rouge">&lt;router-outlet&gt;&lt;/router-outlet&gt;</code> directive to the host component template</li>
  <li>Can remove ‚Äúselectors‚Äù for routed components (only required for nested components)</li>
</ol>

<h1 id="navigation-and-routing-additional-techniques">Navigation and Routing Additional Techniques</h1>
<ul>
  <li>Two different ways to get parameters from ActivatedRoute - snapshot or observable</li>
  <li>Use the snapshot approach if only initial value of a parameter is needed e.g. <code class="highlighter-rouge">this.route.snapshot.paramMap.get('id')</code></li>
  <li>Use the observable approach if you were navigating to the same component but using a new parameter e.g. a next button to get the next product details</li>
  <li>Can route programatically using the <code class="highlighter-rouge">Router</code> service. Inject it into the component required, and then call the <code class="highlighter-rouge">navigate()</code> method e.g. <code class="highlighter-rouge">this.route.navigate(['/products'])</code></li>
</ul>

<h2 id="guards">Guards</h2>
<ul>
  <li>Use guards to protect access to e.g. admin only or to ensure a user doesn‚Äôt navigate away from a page before saving.</li>
  <li>Several guards include:
    <ul>
      <li><code class="highlighter-rouge">CanActivate</code> - guard navigation TO a route;</li>
      <li><code class="highlighter-rouge">CanDeactivate</code> - guard navigation FROM a route;</li>
      <li><code class="highlighter-rouge">Resolve</code> - prefetch data before activating a route;</li>
      <li><code class="highlighter-rouge">CanLoad</code> - prevent async routing</li>
    </ul>
  </li>
  <li>Create a class for the guard service e.g. <code class="highlighter-rouge">ProductDetailsGuard</code> which implements the interface for the desired guard (<code class="highlighter-rouge">ng generate guard [name]</code>)</li>
  <li>Add details of the class to the route config e.g. <code class="highlighter-rouge">{ path: 'products/:id', component: ProductDetailsComponent, canActivate: [ProductDetailsGuard] }</code></li>
</ul>

<h1 id="angular-modules-1">Angular Modules</h1>
<ul>
  <li>An Angular Module is a class with an <code class="highlighter-rouge">NgModule</code> decorator</li>
  <li>It can aggregate classes from other modules and reexport them conveniently e.g. <code class="highlighter-rouge">BrowserModule</code>, <code class="highlighter-rouge">HttpModule</code> and <code class="highlighter-rouge">RouterModule</code></li>
  <li>Modules can be loaded eagerly at application start or lazy loaded by the router (discussed in the Angular Routing course)</li>
  <li>Modules declare components, directives and pipes - each of these <strong>belong</strong> to an angular module</li>
  <li>An Angular Module bootstraps our root application component, defining the component needed to display the first template</li>
  <li>Modules import and export artefacts from and to other modules</li>
  <li>Modules register service providers with the injector</li>
</ul>

<h2 id="bootstrap-array">Bootstrap Array</h2>
<ul>
  <li><code class="highlighter-rouge">AppModule</code> bootstraps <code class="highlighter-rouge">AppComponent</code> via a directive in index.html e.g. <code class="highlighter-rouge">&lt;pm-root&gt;&lt;/pm-root&gt;</code></li>
  <li><code class="highlighter-rouge">AppModule</code>‚Äôs <code class="highlighter-rouge">@NgModule() </code>decorator contains a <code class="highlighter-rouge">bootstrap</code> property which has an array of components to bootstrap e.g. <code class="highlighter-rouge">[AppComponent]</code></li>
  <li>The bootstrap array should only be used in the root application module</li>
  <li>It must contain at least one component</li>
</ul>

<h2 id="declarations-array">Declarations Array</h2>
<ul>
  <li>Define the components which belong to this module</li>
  <li>Each component, directive and pipe has must belong to <strong>one and only one</strong> module</li>
  <li>Only add components, directives and pipes to this array</li>
  <li>Components, directives and pipes are private to this module by default</li>
  <li>An angular module provides the template resolution environments for its components templates</li>
</ul>

<h2 id="exports-array">Exports Array</h2>
<ul>
  <li>Share a modules components, directives and pipes with other modules by adding them to the <code class="highlighter-rouge">exports</code> array</li>
  <li>Can re-export system Angular modules e.g. <code class="highlighter-rouge">HttpModule</code></li>
  <li>Can re-export 3rd party Angular modules e.g. Material Design (https://material.angular.io)</li>
  <li>Can re-export the app‚Äôs own modules</li>
  <li>Can re-export something without importing it first e.g. our <code class="highlighter-rouge">SharedModule</code> exports the <code class="highlighter-rouge">FormsModule</code> - any other module which imports <code class="highlighter-rouge">SharedModule</code> will automatically have access to <code class="highlighter-rouge">ngModel</code></li>
  <li>Never export a service - they are added to the root application injector - then available to ANY class in the application</li>
</ul>

<h2 id="imports-array">Imports Array</h2>
<ul>
  <li>Import supporting modules that export components, directives or pipes which this module needs</li>
  <li>Imports are NOT inherited unless those imports are re-exported - think of a module as a box NOT as a tree structure</li>
</ul>

<h2 id="providers-array">Providers Array</h2>
<ul>
  <li>Originally used to register services for the application BUT NO LONGER RECOMMENDED</li>
  <li>Instead (from Angular 6) use the <code class="highlighter-rouge">providedIn</code> property of the service itself</li>
  <li>Notes on the Providers array (for legacy code):
    <ul>
      <li>All services in the providers array of a given module are registered at the ROOT (not just with that module)</li>
      <li>If you want to ensure that service is local, register it with the providers array of a component instead</li>
      <li>Lazy loaded services are different</li>
      <li>Don‚Äôt add services to a shared module‚Äôs providers array (for reasons above) - instead consider creating a <code class="highlighter-rouge">CoreModule</code> and importing this ONCE if you want to separate in this way</li>
    </ul>
  </li>
</ul>

<h1 id="building-testing-and-deploying-with-the-cli">Building, Testing, and Deploying with the CLI</h1>

<h1 id="final-words">Final Words</h1>
:ET